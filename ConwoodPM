import sys
import datetime
import pymysql
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QPushButton, 
                            QTableWidget, QTableWidgetItem, QHeaderView, QTabWidget, QComboBox, QFormLayout, QGroupBox,QMessageBox,
                            QDialogButtonBox, QDialog, QDateEdit, QScrollArea, QSpacerItem, QSizePolicy, QMenu, QAbstractItemView, QCheckBox, QCalendarWidget )
from PyQt5.QtCore import QTimer, Qt, QDate
from PyQt5.QtPrintSupport import QPrinter, QPrintDialog
from PyQt5.QtGui import QCursor
from PyQt5 import sip
from PyQt5.QtWebEngineWidgets import QWebEngineView, QWebEngineProfile, QWebEngineSettings
import pandas as pd
from bs4 import BeautifulSoup
import os
import base64

import pymysql


class CustomTableWidget(QTableWidget):
    def __init__(self, *args, **kwargs):
        super(CustomTableWidget, self).__init__(*args, **kwargs)
        self.setEditTriggers(QAbstractItemView.DoubleClicked | QAbstractItemView.EditKeyPressed)
        self.setSelectionMode(QAbstractItemView.MultiSelection)
        self.setSelectionBehavior(QAbstractItemView.SelectItems)

    def flags(self, index):
        if index.column() == 9:  # Asumsikan kolom "Comment" adalah kolom ke-10
            return super().flags(index) | Qt.ItemIsEditable
        return super().flags(index)

    def contextMenuEvent(self, event):
        print("Context menu opened.")  
        context_menu = QMenu(self)

        copy_action = context_menu.addAction("Copy")
        copy_action.triggered.connect(self.copy_selection_to_clipboard)

        # Tampilkan menu konteks di posisi kursor
        context_menu.popup(QCursor.pos())

    def copy_selection_to_clipboard(self):
        selection = self.selectedIndexes()
        if selection:
            rows = sorted(index.row() for index in selection)
            columns = sorted(index.column() for index in selection)
            rowcount = rows[-1] - rows[0] + 1
            colcount = columns[-1] - columns[0] + 1
            table = [[''] * colcount for _ in range(rowcount)]
            for index in selection:
                row = index.row() - rows[0]
                col = index.column() - columns[0]
                if col == 8:  # Assuming 'Checklist' is at index 8 after 'Standard'
                    # Get the checkbox widget
                    checkbox_widget = self.cellWidget(index.row(), index.column())
                    # Get the checkbox value
                    checkbox_value = 'Checked' if checkbox_widget.findChild(QCheckBox).isChecked() else 'Unchecked'
                    table[row][col] = checkbox_value
                else:
                    table[row][col] = index.data() if index.data() is not None else ''  # periksa jika data adalah None

            stream = '\n'.join(['\t'.join(row) for row in table])
            QApplication.clipboard().setText(stream)

    def keyPressEvent(self, event):
        if event.key() == Qt.Key_C and event.modifiers() == Qt.ControlModifier:
            print("CTRL+C pressed")  # ini hanya untuk debugging
            self.copy_selection_to_clipboard()
        else:
            super().keyPressEvent(event)


class DatabaseManager:
    def __init__(self):
        self.host = 'localhost'
        self.user = 'root'
        self.password = ''
        self.database = 'conwood'
        self.connection = self.connect_to_db()
        self.cursor = self.connection.cursor()  # Menambahkan cursor di sini

    def connect_to_db(self):
        return pymysql.connect(host=self.host, user=self.user, password=self.password, database=self.database)

    def execute_query(self, query, params=None):
        try:
            with self.connection.cursor() as cursor:  # Menjamin cursor ditutup setelah selesai
                cursor.execute(query, params)

                if query.strip().upper().startswith(("INSERT", "UPDATE", "DELETE")):
                    self.connection.commit()
                return True

        except Exception as e:
            print(f"Database error: {e}")
            return False
        
    def get_all_machines_with_ids(self):
        try:
            self.cursor.execute("SELECT id, name FROM machinepm")
            return self.cursor.fetchall()
        except Exception as e:
            print(f"Error retrieving machines: {e}")
            return False
        
    def get_all_parts_with_ids(self):
        try:
            self.cursor.execute("SELECT id, bagian_mesin FROM machinepm")
            return self.cursor.fetchall()
        except Exception as e:
            print(f"Error retrieving parts: {e}")
            return False
        
    def get_all_labor_with_ids(self):
        try:
            self.cursor.execute("SELECT id, labor FROM machinepm")
            return self.cursor.fetchall()
        except Exception as e:
            print(f"Error retrieving parts: {e}")
            return False
        
    def electric_get_all_machines_with_ids(self):
        try:
            self.cursor.execute("SELECT id, name FROM electricpm")
            return self.cursor.fetchall()
        except Exception as e:
            print(f"Error retrieving machines: {e}")
            return False
        
    def electric_get_all_parts_with_ids(self):
        try:
            self.cursor.execute("SELECT id, bagian_mesin FROM electricpm")
            return self.cursor.fetchall()
        except Exception as e:
            print(f"Error retrieving parts: {e}")
            return False
        
    def electric_get_all_labor_with_ids(self):
        try:
            self.cursor.execute("SELECT id, labor FROM electricpm")
            return self.cursor.fetchall()
        except Exception as e:
            print(f"Error retrieving parts: {e}")
            return False

    def fetch_data(self, query, params=None):
        try:
            with self.connection.cursor() as cursor:
                cursor.execute(query, params)
                return cursor.fetchall()
        except Exception as e:
            print(f"Database error: {e}")
            return None

    def close_connection(self):
        if self.cursor:  # Menutup cursor
            self.cursor.close()
        if self.connection:
            self.connection.close()

    def fetch_one(self, query, params=None):
        try:
            with self.connection.cursor() as cursor:  # Menggunakan with statement untuk menjamin cursor ditutup setelah digunakan
                cursor.execute(query, params)
                return cursor.fetchone()
        except Exception as e:
            print(f"Database error: {e}")
            return None

class MaintenanceApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.db_manager = DatabaseManager()

        self.setWindowTitle("Preventive Maintenance Logger")
        self.setGeometry(100, 100, 1200, 800)

        self.details_inputs = []
        self.standard_inputs = []
        self.frequency_pemeriksaan_combos = []
        self.spare_part_inputs = []
        self.part_number_inputs = []
        self.maintenance_date_inputs = []
        self.electric_details_inputs = []
        self.electric_standard_inputs = []
        self.electric_frequency_pemeriksaan_combos = []
        self.electric_spare_part_inputs = []
        self.electric_part_number_inputs = []
        self.electric_maintenance_date_inputs = []

        self.entries = []

        self.current_page = 1
        self.electric_current_page = 1
        self.current_page_history = 1
        self.rows_per_page = 100  # Menampilkan 200 baris per halaman, sesuaikan sesuai kebutuhan
        self.electric_rows_per_page = 100



        self.central_widget = QTabWidget()
        self.setCentralWidget(self.central_widget)

        # Machine tab
        self.machine_tab = QWidget()
        self.central_widget.addTab(self.machine_tab, "Mechanical")
        self.setup_machine_tab()

        # Electric tab
        self.electric_tab = QWidget()
        self.central_widget.addTab(self.electric_tab, "Electric")
        self.setup_electric_tab()

        # Output tab
        self.output_tab = QWidget()
        self.central_widget.addTab(self.output_tab, "Schedule")
        self.setup_output_tab()

        # Output Electric tab
        self.output_electric_tab = QWidget()
        self.central_widget.addTab(self.output_electric_tab, "Output Electric")
        self.electric_setup_output_tab()
        self.central_widget.tabBar().setTabVisible(self.central_widget.indexOf(self.output_electric_tab), False)

        # Next Maintenance tab
        self.next_maintenance_tab = QWidget()
        self.central_widget.addTab(self.next_maintenance_tab, "In progress")
        self.setup_next_maintenance_tab()

        # Next Maintenance Electric tab
        self.next_maintenance_electric_tab = QWidget()
        self.central_widget.addTab(self.next_maintenance_electric_tab, "ElectricPM")
        self.setup_next_maintenance_electric_tab()
        self.central_widget.tabBar().setTabVisible(self.central_widget.indexOf(self.next_maintenance_electric_tab), False)
        self.search_by_name_combo_output.currentIndexChanged.connect(self.update_part_combo)

        # History tab
        self.history_tab = QWidget()  # New History tab
        self.central_widget.addTab(self.history_tab, "History")
        self.setup_history_tab()  # Anda harus membuat fungsi ini untuk mengatur tab History

        # Electric History tab
        self.electric_history_tab = QWidget()  # New History tab
        self.central_widget.addTab(self.electric_history_tab, "Electric History")
        self.electric_setup_history_tab()  # Anda harus membuat fungsi ini untuk mengatur tab History
        self.central_widget.tabBar().setTabVisible(self.central_widget.indexOf(self.electric_history_tab), False)

        self.central_widget.currentChanged.connect(self.on_tab_changed)

        # Set up a QTimer for real-time updates
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_maintenance_entries)
        self.timer.start(1000)  # Update every 1000 ms (1 second)
        self.search_by_labor_combo_output.currentIndexChanged.connect(self.update_machine_and_part_combos)
        self.search_by_labor_combo.currentIndexChanged.connect(self.update_machine_combo_next_maintenance)
        self.search_by_labor_combo_history.currentIndexChanged.connect(self.update_machine_and_part_combos_history)
        self.electric_search_by_labor_combo_output.currentIndexChanged.connect(self.electric_update_machine_and_part_combos)
        self.electric_search_by_labor_combo_history.currentIndexChanged.connect(self.electric_update_machine_and_part_combos_history)
        
        
        self.last_filter_conditions = None  # variabel untuk menyimpan kondisi filter terakhir
        self.search_by_name_combo_output.currentIndexChanged.connect(self.update_part_combo)
        self.search_by_name_combo.currentIndexChanged.connect(self.update_part_combo_next_maintenance)
        self.search_by_name_combo_history.currentIndexChanged.connect(self.update_part_combo_history)
        self.electric_search_by_name_combo_output.currentIndexChanged.connect(self.electric_update_part_combo)
        self.electric_search_by_name_combo_history.currentIndexChanged.connect(self.electric_update_part_combo_history)

    def next_page(self):
        self.current_page += 1
        self.update_output_with_filter_conditions()  # panggil metode ini untuk mengupdate output

    def electric_next_page(self):
        self.electric_current_page += 1
        self.electric_update_output_with_filter_conditions()  # pastikan metode ini telah didefinisikan

    def next_page_history(self):
        self.current_page_history += 1
        self.update_history_with_filter_conditions()  # Update the table with the new page of data
        self.update_page_label_history()  # Update the page label

    def electric_next_page_history(self):
        self.electric_current_page += 1
        self.electric_update_history_with_filter_conditions()  # Update the table with the new page of data
        self.electric_update_page_label_history()  # Update the page label

    def prev_page(self):
        if self.current_page > 1:
            self.current_page -= 1
            self.update_output_with_filter_conditions()  # panggil metode ini untuk mengupdate output

    def electric_prev_page(self):
        if self.electric_current_page > 1:
            self.electric_current_page -= 1
            self.electric_update_output_with_filter_conditions()  # pastikan metode ini telah didefinisikan

    def prev_page_history(self):
        if self.current_page_history > 1:
            self.current_page_history -= 1
            self.update_history_with_filter_conditions()  # Update the table with the new page of data
            self.update_page_label_history()  # Update the page label

    def electric_prev_page_history(self):
        if self.electric_current_page > 1:
            self.electric_current_page -= 1
            self.electric_update_history_with_filter_conditions()  # Update the table with the new page of data
            self.electric_update_page_label_history()  # Update the page label

    def update_output_with_filter_conditions(self):
        start = (self.current_page - 1) * self.rows_per_page
        query = f"""
        SELECT id, labor, name, bagian_mesin, frequency_pemeriksaan, deskripsi, spare_part, part_number, standard, date, next_maintenance_date, status 
        FROM machinePM
        WHERE status = 'Start'
        """
        if self.last_filter_conditions:
            query += f" AND {' AND '.join(self.last_filter_conditions)}"
        query += f" ORDER BY next_maintenance_date ASC, id ASC"  # Apply sorting condition here
        query += f" LIMIT {self.rows_per_page} OFFSET {start}"
        
        self.populate_output_tab(query)

    def electric_update_output_with_filter_conditions(self):
        start = (self.electric_current_page - 1) * self.rows_per_page
        query = f"""
        SELECT id, labor, name, bagian_mesin, frequency_pemeriksaan, deskripsi, spare_part, part_number, standard, date, next_maintenance_date, status 
        FROM electricPM  # Asumsi nama tabel adalah electricPM, silakan ubah jika berbeda
        WHERE status = 'Start'
        """
        if self.electric_last_filter_conditions:
            query += f" AND {' AND '.join(self.electric_last_filter_conditions)}"
        query += f" ORDER BY date ASC, id ASC LIMIT {self.rows_per_page} OFFSET {start}"
        
        self.electric_populate_output_tab(query)  # pastikan metode ini telah didefinisikan


    def update_history_with_filter_conditions(self):
        start = (self.current_page_history - 1) * self.rows_per_page
        query = f"""
        SELECT id, labor, name, bagian_mesin, frequency_pemeriksaan, deskripsi, spare_part, part_number, standard, date, next_maintenance_date, status 
        FROM machinePM
        WHERE status != 'Start'
        """
        if self.last_filter_conditions_history:
            query += f" AND {' AND '.join(self.last_filter_conditions_history)}"
        query += f" ORDER BY date ASC, id ASC LIMIT {self.rows_per_page} OFFSET {start}"
        
        self.populate_history_tab(query)

    def electric_update_history_with_filter_conditions(self):
        start = (self.electric_current_page - 1) * self.electric_rows_per_page
        query = f"""
        SELECT id, labor, name, bagian_mesin, frequency_pemeriksaan, deskripsi, spare_part, part_number, standard, date, next_maintenance_date, status 
        FROM electricPM
        WHERE status != 'Start'
        """
        if self.electric_last_filter_conditions_history:
            query += f" AND {' AND '.join(self.electric_last_filter_conditions_history)}"
        query += f" ORDER BY date ASC, id ASC LIMIT {self.electric_rows_per_page} OFFSET {start}"
        
        self.electric_populate_history_tab(query) 

    def update_page_label(self):
        self.page_label.setText(f"Page {self.current_page}")

    def electric_update_page_label(self):
        self.electric_page_label.setText(f"Page {self.electric_current_page}")

    def update_page_label_history(self):
        self.page_label_history.setText(f"Page {self.current_page_history}")

    def electric_update_page_label_history(self):
        self.electric_page_label_history.setText(f"Page {self.electric_current_page}")

    def update_pagination(self):
        total_rows = sum(1 for i in range(self.table.rowCount()) if not self.table.isRowHidden(i))  # Hitung jumlah baris yang tidak disembunyikan
        start = (self.current_page - 1) * self.rows_per_page
        end = start + self.rows_per_page
        displayed_rows = 0  # Hitung jumlah baris yang ditampilkan

        for i in range(self.table.rowCount()):
            if not self.table.isRowHidden(i):
                should_display = displayed_rows >= start and displayed_rows < end
                self.table.setRowHidden(i, not should_display)
                displayed_rows += 1

    def update_pagination_history(self):
        total_rows = sum(1 for i in range(self.history_table.rowCount()) if not self.history_table.isRowHidden(i))
        start = (self.current_page_history - 1) * self.rows_per_page
        end = start + self.rows_per_page
        displayed_rows = 0

        for i in range(self.history_table.rowCount()):
            if not self.history_table.isRowHidden(i):
                should_display = displayed_rows >= start and displayed_rows < end
                self.history_table.setRowHidden(i, not should_display)
                displayed_rows += 1

    def show_edit_dialog(self, selected_name, selected_labor):
        query = "SELECT * FROM machinePM WHERE name = %s AND labor = %s"
        data_rows = self.db_manager.fetch_data(query, (selected_name, selected_labor))

        if not data_rows:
            return

        first_row = data_rows[0]

        dialog = QDialog(self)
        dialog.setWindowTitle("Edit Entries")
        layout = QFormLayout(dialog)
        dialog.setFixedWidth(500)

        labor_combo = QComboBox()
        labor_combo.addItem("Pilih Area / Labor")
        labor_combo.addItems(["Fiber Preparation", "Utility", "Final Mix", "Laminating", "Dryer", "Finishing"])
        labor_combo.setCurrentText(str(first_row[1]))

        frequency_pemeriksaan_combo = QComboBox()
        frequency_pemeriksaan_combo.addItems(["Pilih Frequency", "1W", "2W", "1M", "3M", "6M", "1Y", "2Y", "3Y", "4Y", "5Y"])
        frequency_pemeriksaan_combo.setCurrentText(str(first_row[4]))

        iterasi_combo = QComboBox()
        iterasi_combo.addItem("Pilih Iterasi")
        iterasi_combo.addItems(["1", "2", "3", "4", "5"])
        iterasi_combo.setCurrentText(str(first_row[12]))

        name_input = QLineEdit(str(first_row[2]))
        bagian_mesin_input = QLineEdit(str(first_row[3]))
        deskripsi_input = QLineEdit(str(first_row[5]))
        spare_part_input = QLineEdit(str(first_row[6]))
        part_number_input = QLineEdit(str(first_row[7]))
        standard_input = QLineEdit(str(first_row[8]))

        layout.addRow("Labor", labor_combo)
        layout.addRow("Nama Mesin", name_input)
        layout.addRow("Bagian Mesin", bagian_mesin_input)
        layout.addRow("Job Frequency", frequency_pemeriksaan_combo)
        layout.addRow("Iterasi (Tahun)", iterasi_combo)
        layout.addRow("Job Activity", deskripsi_input)
        layout.addRow("Spare Part", spare_part_input)
        layout.addRow("Part Number", part_number_input)
        layout.addRow("Standard", standard_input)

        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, Qt.Horizontal, dialog)
        layout.addRow(buttons)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)

        result = dialog.exec_()

        if result == QDialog.Accepted:
            new_values = [
                labor_combo.currentText(),
                name_input.text(),
                bagian_mesin_input.text(),
                frequency_pemeriksaan_combo.currentText(),
                deskripsi_input.text(),
                spare_part_input.text(),
                part_number_input.text(),
                standard_input.text(),
                iterasi_combo.currentText()
            ]

            update_query = """
            UPDATE machinePM SET
                labor = %s, name = %s, bagian_mesin = %s, frequency_pemeriksaan = %s, deskripsi = %s,
                spare_part = %s, part_number = %s, standard = %s, iterasi_tahun = %s
            WHERE name = %s AND labor = %s
            """
            self.db_manager.execute_query(update_query, (*new_values, selected_name, selected_labor))
            self.populate_output_tab()

    def electric_show_edit_dialog(self, item_id):
        # Fetch the current data for this item_id from the electric table
        query = "SELECT * FROM electricpm WHERE id = %s"  # Change 'electricTable' to your electric table name
        data = self.db_manager.fetch_one(query, (item_id,))

        # Create the dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("Edit Entry")
        layout = QFormLayout(dialog)

        # Set a fixed width for the dialog
        dialog.setFixedWidth(500)  # Set the width as per your requirement

        # Widgets for Labor, Frequency Pemeriksaan, and Iterasi (Tahun)
        labor_combo = QComboBox()
        labor_combo.addItem("Pilih Area / Labor")
        labor_combo.addItems(["Fiber Preparation", "Utility", "Final Mix", "Laminating", "Dryer", "Finishing"])
        labor_combo.setCurrentText(str(data[1]))  # Set current text to current value from database

        frequency_pemeriksaan_combo = QComboBox()
        frequency_pemeriksaan_combo.addItems(["Pilih Frequency", "1W", "2W", "1M", "3M", "6M", "1Y", "2Y", "3Y", "4Y", "5Y"])
        frequency_pemeriksaan_combo.setCurrentText(str(data[4]))  # Set current text to current value from database

        iterasi_combo = QComboBox()
        iterasi_combo.addItem("Pilih Iterasi")
        iterasi_combo.addItems(["1", "2", "3", "4", "5"])
        iterasi_combo.setCurrentText(str(data[12]))  # Set current text to current value from database

        # Other fields
        name_input = QLineEdit(str(data[2]))
        bagian_mesin_input = QLineEdit(str(data[3]))
        deskripsi_input = QLineEdit(str(data[5]))
        spare_part_input = QLineEdit(str(data[6]))
        part_number_input = QLineEdit(str(data[7]))
        standard_input = QLineEdit(str(data[8]))
        date_input = QDateEdit(QDate.fromString(str(data[9]), 'yyyy-MM-dd'))
        next_maintenance_date_input = QDateEdit(QDate.fromString(str(data[10]), 'yyyy-MM-dd'))

        # Populate the form with current data
        layout.addRow("Labor", labor_combo)
        layout.addRow("Nama Mesin", name_input)
        layout.addRow("Bagian Mesin", bagian_mesin_input)
        layout.addRow("Job Frequency", frequency_pemeriksaan_combo)
        layout.addRow("Iterasi (Tahun)", iterasi_combo)
        layout.addRow("Job Activity", deskripsi_input)
        layout.addRow("Spare Part", spare_part_input)
        layout.addRow("Part Number", part_number_input)
        layout.addRow("Standard", standard_input)
        layout.addRow("Date", date_input)
        layout.addRow("Next PM", next_maintenance_date_input)

        # Buttons to save or cancel
        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, Qt.Horizontal, dialog)
        layout.addRow(buttons)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)

        # Show the dialog
        result = dialog.exec_()

        # If the user pressed OK, then update the database
        if result == QDialog.Accepted:
            new_values = [
                labor_combo.currentText(),
                name_input.text(),
                bagian_mesin_input.text(),
                frequency_pemeriksaan_combo.currentText(),
                deskripsi_input.text(),
                spare_part_input.text(),
                part_number_input.text(),
                standard_input.text(),
                date_input.date().toString('yyyy-MM-dd'),
                next_maintenance_date_input.date().toString('yyyy-MM-dd'),
                iterasi_combo.currentText()
            ]
            update_query = """
            UPDATE electricpm SET  
                labor = %s, name = %s, bagian_mesin = %s, frequency_pemeriksaan = %s, deskripsi = %s,
                spare_part = %s, part_number = %s, standard = %s, date = %s, next_maintenance_date = %s,
                iterasi_tahun = %s
            WHERE id = %s
            """
            self.db_manager.execute_query(update_query, (*new_values, item_id))

            # Refresh the output tab
            self.electric_populate_output_tab()  # Change this method name if necessary



    def on_delete_button_clicked(self, item_id):
        # Tampilkan dialog konfirmasi
        reply = QMessageBox.question(self, 'Delete Confirmation',
                                     'Are you sure you want to delete this entry?', QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

        if reply == QMessageBox.Yes:
            query = "DELETE FROM machinePM WHERE id = %s"
            self.db_manager.execute_query(query, (item_id,))
            self.populate_output_tab()  # Perbarui tabel output

    def electric_on_delete_button_clicked(self, item_id):
        # Tampilkan dialog konfirmasi
        reply = QMessageBox.question(self, 'Delete Confirmation',
                                    'Are you sure you want to delete this entry?', QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

        if reply == QMessageBox.Yes:
            query = "DELETE FROM electricPM WHERE id = %s"  # Asumsikan nama tabel adalah electricMachinePM
            self.db_manager.execute_query(query, (item_id,))
            self.electric_populate_output_tab()  # Perbarui tabel output electric



    def on_tab_changed(self, index):
        current_tab = self.central_widget.widget(index)
        if current_tab == self.output_tab:
            self.populate_output_tab()
        elif current_tab == self.output_electric_tab:
            self.electric_populate_output_tab()
        elif current_tab == self.next_maintenance_tab:
            self.populate_next_maintenance_tab()
        elif current_tab == self.next_maintenance_electric_tab:
            self.populate_next_maintenance_electric_tab()
        elif current_tab == self.history_tab:
            self.populate_history_tab()
        elif current_tab == self.electric_history_tab:
            self.populate_history_tab()
        

    def fetch_one(self, query, params):
        self.cursor.execute(query, params)
        return self.cursor.fetchone()

    def on_cancel_button_clicked(self, item_id):
        # Update status in the database
        query = """
        UPDATE machinePM
        SET status = %s
        WHERE id = %s
        """
        self.db_manager.execute_query(query, ("Start", item_id))
        
        # Refresh the output tab to display the cancelled entry
        self.populate_output_tab()
        
        # Remove the entry from the next maintenance table
        for i in range(self.next_maintenance_table.rowCount()):
            if self.next_maintenance_table.item(i, 9).data(Qt.UserRole) == item_id:  # adjust the column index according to your table
                self.next_maintenance_table.removeRow(i)
                break
        
        # Refresh the next maintenance tab
        self.populate_next_maintenance_tab()

    def electric_on_cancel_button_clicked(self, item_id):
        # Update status in the database
        query = """
        UPDATE electricpm
        SET status = %s
        WHERE id = %s
        """
        self.db_manager.execute_query(query, ("Start", item_id))
        
        # Refresh the output tab to display the cancelled entry
        self.electric_populate_output_tab()
        
        # Remove the entry from the electric next maintenance table
        for i in range(self.electric_next_maintenance_table.rowCount()):
            if self.electric_next_maintenance_table.item(i, 9).data(Qt.UserRole) == item_id:  # adjust the column index according to your table
                self.electric_next_maintenance_table.removeRow(i)
                break
        
        # Refresh the electric next maintenance tab
        self.populate_next_maintenance_electric_tab()

    def find_row_by_id_in_table(self, item_id):
        for row in range(self.table.rowCount()):
            # Assuming the item_id is stored in the first column as hidden data
            if self.table.item(row, 0).data(Qt.UserRole) == item_id:
                return row
        return None



    def find_row_by_id(self, item_id):
        for row in range(self.next_maintenance_table.rowCount()):
            item = self.next_maintenance_table.item(row, 0)  # Assuming 'labor' is at column 0
            if item and item.data(Qt.UserRole) == item_id:
                return row
        return None



    def on_status_button_clicked(self, item_id):
        # Simpan kondisi filter sebelum melakukan tindakan
        saved_filter_conditions = self.last_filter_conditions.copy() if self.last_filter_conditions else []

        query = "SELECT * FROM machinePM WHERE id=%s"
        data = self.db_manager.fetch_one(query, (item_id,))
        if not data:
            print("Data not found for ID:", item_id)
            return

        # Attempt to find the row in the next_maintenance_table
        next_maintenance_row = self.find_row_by_id(item_id)
        # Attempt to find the row in the output_table
        output_table_row = self.find_row_by_id_in_table(item_id)

        # If the item_id is not found in either table, return
        if next_maintenance_row is None and output_table_row is None:
            print("Row not found for ID in any table:", item_id)
            return

        current_status = data[11]  # Assuming status is the 12th element in the data
        iterasi_tahun = data[12]   # Assuming iterasi_tahun is the 13th element in the data

        if iterasi_tahun is None:
            print("Iterasi tahun tidak ditemukan untuk ID:", item_id)
            return

        try:
            iterasi_tahun = int(iterasi_tahun)
        except ValueError:
            print("Iterasi tahun tidak valid untuk ID:", item_id)
            return

        # Handle "Start" status in the output_table
        if output_table_row is not None and current_status == "Start":
            self.db_manager.execute_query("UPDATE machinePM SET status = %s WHERE id = %s", ("In Progress", item_id))
            self.populate_next_maintenance_tab()
            self.populate_output_tab()

        # Handle "In Progress" status in the next_maintenance_table
        elif next_maintenance_row is not None and current_status == "In Progress":
            checkbox_widget = self.next_maintenance_table.cellWidget(next_maintenance_row, 8)  # Assuming "Checklist" column is the 9th
            checkbox = checkbox_widget.layout().itemAt(0).widget()
            checklist_status = "Checked" if checkbox.isChecked() else "Unchecked"

            comment_item = self.next_maintenance_table.item(next_maintenance_row, 9)  # Assuming "Comment" column is the 10th
            comment_text = comment_item.text() if comment_item else ""

            self.db_manager.execute_query("UPDATE machinePM SET status = %s, checklist = %s, comment = %s WHERE id = %s",
                                        ("Completed", checklist_status, comment_text, item_id))

            # Calculate the next maintenance date
            frequency_pemeriksaan = data[4]
            next_maintenance_date = data[10]  # Directly use the date object if it's already a date
            frequency_pemeriksaan_days = self.frequency_pemeriksaan_to_days(frequency_pemeriksaan)
            total_days_to_add = frequency_pemeriksaan_days * (iterasi_tahun * 365 // frequency_pemeriksaan_days)
            next_maintenance_date += datetime.timedelta(days=total_days_to_add)

            # Insert new entry for the next maintenance
            self.db_manager.execute_query(
                "INSERT INTO machinePM (labor, name, bagian_mesin, frequency_pemeriksaan, deskripsi, spare_part, part_number, standard, date, next_maintenance_date, status, iterasi_tahun) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)",
                (data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], data[9], next_maintenance_date, "Start", iterasi_tahun)
            )
            
            self.populate_next_maintenance_tab()
            self.populate_output_tab()

        else:
            print("Unknown status or table for ID:", item_id)

        # Terapkan kembali kondisi filter setelah memperbarui tabel
        self.last_filter_conditions = saved_filter_conditions
        self.update_output_with_filter_conditions()

    def electric_on_status_button_clicked(self, item_id):
        query = "SELECT * FROM electricPM WHERE id=%s"  # Asumsikan nama tabel adalah electricPM
        data = self.db_manager.fetch_one(query, (item_id,))
        if not data:
            print("Data not found")
            return

        current_status = data[11]  # Index diperbarui karena menambahkan kolom "Labor"
        iterasi_tahun = data[12]  # Asumsikan bahwa iterasi_tahun adalah kolom ke-13 di tabel Anda

        if iterasi_tahun is None:
            print("Iterasi tahun tidak ditemukan")
            return

        # Konversi iterasi_tahun ke integer
        try:
            iterasi_tahun = int(iterasi_tahun)
        except ValueError:
            print("Iterasi tahun tidak valid")
            return

        if current_status == "Start":
            query = """
            UPDATE electricPM
            SET status = %s
            WHERE id = %s
            """
            self.db_manager.execute_query(query, ("In Progress", item_id))

            row_position = self.electric_next_maintenance_table.rowCount()
            self.electric_next_maintenance_table.insertRow(row_position)
            for i in range(10):  # Index diperbarui karena menambahkan kolom "Labor"
                self.electric_next_maintenance_table.setItem(row_position, i, QTableWidgetItem(str(data[i+1])))
            self.electric_next_maintenance_table.setItem(row_position, 10, QTableWidgetItem("In Progress"))  # Index diperbarui karena menambahkan kolom "Labor"

            self.electric_populate_output_tab()

        elif current_status == "In Progress":
            query = """
            UPDATE electricPM
            SET status = %s
            WHERE id = %s
            """
            self.db_manager.execute_query(query, ("Completed", item_id))

            # Ambil frekuensi dari entri database
            frequency_pemeriksaan = data[4]

            # Menghitung tanggal pemeliharaan berikutnya dengan menambahkan tahun ke tanggal saat ini
            next_maintenance_date = datetime.datetime.strptime(str(data[10]), "%Y-%m-%d").date()
            frequency_pemeriksaan_days = self.electric_frequency_pemeriksaan_to_days(frequency_pemeriksaan)
            total_days_to_add = frequency_pemeriksaan_days * (iterasi_tahun * 365 // frequency_pemeriksaan_days)
            next_maintenance_date += datetime.timedelta(days=total_days_to_add)

            query = """
            INSERT INTO electricPM (labor, name, bagian_mesin, frequency_pemeriksaan, deskripsi, spare_part, part_number, standard, date, next_maintenance_date, status, iterasi_tahun)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            values = (data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], data[9], next_maintenance_date, "Start", iterasi_tahun)
            self.db_manager.execute_query(query, values)

            row_position = self.electric_history_table.rowCount()
            self.electric_history_table.insertRow(row_position)
            for i in range(10):  # Index updated because of the addition of "Labor" column
                self.electric_history_table.setItem(row_position, i, QTableWidgetItem(str(data[i+1])))
            self.electric_history_table.setItem(row_position, 10, QTableWidgetItem("Completed"))  # Index updated because of the addition of "Labor" column

            self.populate_next_maintenance_electric_tab()
            self.electric_populate_output_tab()  # Ensure this method is updated to handle the new "labor" column and also re-populate the Output tab

        else:
            print("Unknown status:", current_status)



    def populate_output_tab(self, query=None):
        self.table.setRowCount(0)

        if query is None:
            start = (self.current_page - 1) * self.rows_per_page
            query = f"""
                SELECT id, labor, name, bagian_mesin, frequency_pemeriksaan, deskripsi, spare_part, part_number, standard, date, next_maintenance_date, status 
                FROM machinePM
                WHERE status = 'Start'
                ORDER BY next_maintenance_date ASC, id ASC  -- Urutkan berdasarkan next_maintenance_date terlebih dahulu
                LIMIT {self.rows_per_page} OFFSET {start}
            """

        data = self.db_manager.fetch_data(query)

        for row_data in data:
            row_position = self.table.rowCount()
            self.table.insertRow(row_position)
            item_id = row_data[0]  # Assuming the ID is in the first position of row_data
            for col, item in enumerate(row_data[1:], start=0):
                table_item = QTableWidgetItem(str(item))
                if col == 0:  # Assuming the first column after ID should store the ID as hidden data
                    table_item.setData(Qt.UserRole, item_id)
                self.table.setItem(row_position, col, table_item)
            
            # Create a button for the 'Status' action
            status_button = QPushButton("Process", self)
            status_button.clicked.connect(lambda checked, item_id=item_id: self.on_status_button_clicked(item_id))
            
            # Create a button for 'Edit' action
            edit_button = QPushButton("Edit", self)
            edit_button.clicked.connect(lambda checked, name=row_data[2], labor=row_data[1]: self.show_edit_dialog(name, labor))

            
            # Create a button for 'Delete' action
            delete_button = QPushButton("Delete", self)
            delete_button.clicked.connect(lambda checked, item_id=item_id: self.on_delete_button_clicked(item_id))
            
            # Add buttons to the layout
            button_widget = QWidget()
            button_layout = QHBoxLayout(button_widget)
            button_layout.addWidget(status_button)
            button_layout.addWidget(edit_button)
            button_layout.addWidget(delete_button)
            button_layout.setContentsMargins(0, 0, 0, 0)
            button_layout.setSpacing(5)
            self.table.setCellWidget(row_position, 11, button_widget)

        self.update_page_label()  # Ensure the page label is updated


    def electric_populate_output_tab(self, query=None):
        self.electric_table.setRowCount(0)

        if query is None:
            start = (self.electric_current_page - 1) * self.electric_rows_per_page
            query = f"""
            SELECT id, labor, name, bagian_mesin, frequency_pemeriksaan, deskripsi, spare_part, part_number, standard, date, next_maintenance_date, status 
            FROM electricPM
            WHERE status = 'Start'
            ORDER BY date ASC, id ASC
            LIMIT {self.electric_rows_per_page} OFFSET {start}
            """

        electric_data = self.db_manager.fetch_data(query)

        for row_data in electric_data:
            row_position = self.electric_table.rowCount()
            self.electric_table.insertRow(row_position)
            item_id = row_data[0]
            for col, item in enumerate(row_data[1:], start=0):
                self.electric_table.setItem(row_position, col, QTableWidgetItem(str(item)))
            self.electric_table.setItem(row_position, 10, QTableWidgetItem("Start"))
            electric_status_button = QPushButton("Process", self)
            electric_status_button.clicked.connect(lambda checked, item_id=item_id: self.electric_on_status_button_clicked(item_id))
            electric_edit_button = QPushButton("Edit", self)
            electric_edit_button.clicked.connect(lambda checked, item_id=item_id: self.electric_show_edit_dialog(item_id))
            electric_delete_button = QPushButton("Delete", self)
            electric_delete_button.clicked.connect(lambda checked, item_id=item_id: self.electric_on_delete_button_clicked(item_id))
            electric_button_widget = QWidget()
            electric_button_layout = QHBoxLayout(electric_button_widget)
            electric_button_layout.addWidget(electric_status_button)
            electric_button_layout.addWidget(electric_edit_button)
            electric_button_layout.addWidget(electric_delete_button)
            electric_button_layout.setContentsMargins(0, 0, 0, 0)
            electric_button_layout.setSpacing(5)
            self.electric_table.setCellWidget(row_position, 11, electric_button_widget)
            
        self.electric_update_page_label()  # Ensure the page label is updated



    def populate_next_maintenance_tab(self):
        # Clear the table first
        self.next_maintenance_table.setRowCount(0)

        query = """
        SELECT id, labor, name, bagian_mesin, frequency_pemeriksaan, deskripsi, spare_part, part_number, standard, checklist, comment, date, next_maintenance_date, status 
        FROM machinePM
        WHERE status='In Progress'
        ORDER BY labor ASC, name ASC, FIELD(frequency_pemeriksaan, '1W', '2W', '1M', '3M', '6M', '1Y', '2Y', '3Y', '4Y', '5Y')
        """
        data = self.db_manager.fetch_data(query)

        for row_data in data:
            row_position = self.next_maintenance_table.rowCount()
            self.next_maintenance_table.insertRow(row_position)
            
            # Set ID as hidden data in the first column (for example)
            item = QTableWidgetItem(str(row_data[1]))  # 'labor' is the visible data
            item.setData(Qt.UserRole, row_data[0])  # 'id' is stored as invisible data
            self.next_maintenance_table.setItem(row_position, 0, item)

            # Fill the rest of the row with data, skipping the first 'id' column
            for col in range(2, len(row_data)):  # Start from 2 because we already added 'labor'
                if col == 9:  # This is the 'checklist' column, which will be a widget, so we skip it
                    continue
                item = QTableWidgetItem(str(row_data[col]))
                self.next_maintenance_table.setItem(row_position, col - 1, item)  # Subtract 1 because we skipped 'id'
            
            # Add QCheckBox for the "Checklist" column
            checkbox_widget = QWidget()
            checkbox_layout = QHBoxLayout(checkbox_widget)
            checkbox = QCheckBox()
            checkbox.setChecked(row_data[9] == 'Checked')  # Assume 'Checked' is represented by a string 'Checked'
            checkbox_layout.addWidget(checkbox)
            checkbox_layout.setAlignment(Qt.AlignCenter)
            checkbox_layout.setContentsMargins(0,0,0,0)
            self.next_maintenance_table.setCellWidget(row_position, 8, checkbox_widget)  # 'Checklist' is column index 8

            # Add QTableWidgetItem for the "Comment" column
            comment_item = QTableWidgetItem(str(row_data[10]))
            self.next_maintenance_table.setItem(row_position, 9, comment_item)  # 'Comment' is column index 9

            current_id = row_data[0]  # Asumsikan ini adalah ID

            complete_button = QPushButton("Complete")
            complete_button.clicked.connect(lambda checked, item_id=current_id: self.on_status_button_clicked(item_id))
            cancel_button = QPushButton("Cancel")
            cancel_button.clicked.connect(lambda checked, item_id=current_id: self.on_cancel_button_clicked(item_id))

            # Create widget containing both buttons
            action_widget = QWidget()
            action_layout = QHBoxLayout(action_widget)
            action_layout.addWidget(complete_button)
            action_layout.addWidget(cancel_button)
            action_layout.setContentsMargins(0, 0, 0, 0)
            action_widget.setLayout(action_layout)

            self.next_maintenance_table.setCellWidget(row_position, 13, action_widget)  # 'Action' is column index 13

    def populate_next_maintenance_electric_tab(self):
        # Clear the table first
        self.electric_next_maintenance_table.setRowCount(0)

        query = """
        SELECT id, labor, name, bagian_mesin, frequency_pemeriksaan, deskripsi, spare_part, part_number, standard, date, next_maintenance_date, status 
        FROM electricPM
        WHERE status='In Progress'
        ORDER BY labor ASC, name ASC, FIELD(frequency_pemeriksaan, '1W', '2W', '1M', '3M', '6M', '1Y','2Y', '3Y', '4Y', '5Y')
        """
        data = self.db_manager.fetch_data(query)

        for row_data in data:
            row_position = self.electric_next_maintenance_table.rowCount()
            self.electric_next_maintenance_table.insertRow(row_position)

            # Here, row_data[0] is the id from the database.
            item_id = row_data[0]

            # Memasukkan data ke dalam tabel
            for col, item in enumerate(row_data[1:], start=0):
                self.electric_next_maintenance_table.setItem(row_position, col, QTableWidgetItem(str(item)))

            # Tambahkan tombol Complete
            complete_button = QPushButton("Complete", self)
            complete_button.clicked.connect(lambda checked, item_id=item_id: self.electric_on_status_button_clicked(item_id))

            # Tambahkan tombol Cancel
            cancel_button = QPushButton("Cancel", self)
            cancel_button.clicked.connect(lambda checked, item_id=item_id: self.electric_on_cancel_button_clicked(item_id))

            # Membuat widget yang mengandung kedua tombol
            widget = QWidget()
            layout = QHBoxLayout(widget)
            layout.addWidget(complete_button)
            layout.addWidget(cancel_button)
            layout.setContentsMargins(0, 0, 0, 0)
            widget.setLayout(layout)

            self.electric_next_maintenance_table.setCellWidget(row_position, 11, widget)  # Adjust column index accordingly

    def populate_history_tab(self, query=None):
        self.history_table.setRowCount(0)
        
        if query is None:
            query = """
            SELECT id, labor, name, bagian_mesin, frequency_pemeriksaan, deskripsi, spare_part, 
            part_number, standard, checklist, comment, date, next_maintenance_date, status 
            FROM machinePM
            WHERE status = 'Completed'
            ORDER BY date ASC, id ASC
            """
        
        data = self.db_manager.fetch_data(query)
        for row_data in data:
            row_position = self.history_table.rowCount()
            self.history_table.insertRow(row_position)
            for col, item in enumerate(row_data[1:], start=0):  # Adjust the start index if necessary
                if col == 8:  # Assuming 'Checklist' is at index 8 after 'Standard'
                    # Create a checkbox widget and center it
                    checkbox = QCheckBox()
                    checkbox_widget = QWidget()
                    checkbox_layout = QHBoxLayout(checkbox_widget)
                    checkbox_layout.addWidget(checkbox)
                    checkbox_layout.setAlignment(Qt.AlignCenter)
                    checkbox_layout.setContentsMargins(0, 0, 0, 0)
                    checkbox_widget.setLayout(checkbox_layout)
                    
                    checkbox.setChecked(item == 'Checked')  # Set the checkbox based on the item value
                    self.history_table.setCellWidget(row_position, col, checkbox_widget)
                elif col == 9:  # Assuming 'Comment' is at index 9
                    self.history_table.setItem(row_position, col, QTableWidgetItem(str(item)))
                else:
                    self.history_table.setItem(row_position, col, QTableWidgetItem(str(item)))
                    # Adjust other columns accordingly


    def electric_populate_history_tab(self, query=None):
        self.electric_history_table.setRowCount(0)
        
        if query is None:
            query = """
            SELECT id, labor, name, bagian_mesin, frequency_pemeriksaan, deskripsi, spare_part, part_number, standard, date, next_maintenance_date, status 
            FROM electricPM
            WHERE status != 'Start'
            ORDER BY date ASC, id ASC
            """
        
        data = self.db_manager.fetch_data(query)
        for row_data in data:
            row_position = self.electric_history_table.rowCount()
            self.electric_history_table.insertRow(row_position)
            for col, item in enumerate(row_data[1:], start=0):
                self.electric_history_table.setItem(row_position, col, QTableWidgetItem(str(item)))

        


    def populate_combo_output(self, combo, data_type):
        try:
            combo.clear()
            combo.addItem("All")

            items_with_ids = []

            if data_type == 'labor':
                items_with_ids = self.db_manager.get_all_labor_with_ids()
            elif data_type == 'machine':
                items_with_ids = self.db_manager.get_all_machines_with_ids()
            elif data_type == 'part':
                items_with_ids = self.db_manager.get_all_parts_with_ids()
            else:
                print(f"Unsupported data type: {data_type}")
                return

            item_names = {item[1] for item in items_with_ids}  # Mengambil nama item saja dan menghapus duplikat dengan mengubahnya menjadi set

            sorted_item_names = sorted(item_names)  # Sort set items to display

            combo.addItems(sorted_item_names)  # Convert set to list and sort it for better presentation

        except Exception as e:
            print(f"Error populating combo ({data_type}): {e}")

    def electric_populate_combo_output(self, combo, data_type):
        try:
            combo.clear()
            combo.addItem("All")

            items_with_ids = []

            if data_type == 'labor':
                items_with_ids = self.db_manager.electric_get_all_labor_with_ids()
            elif data_type == 'machine':
                items_with_ids = self.db_manager.electric_get_all_machines_with_ids()
            elif data_type == 'part':
                items_with_ids = self.db_manager.electric_get_all_parts_with_ids()
            else:
                print(f"Unsupported data type: {data_type}")
                return

            item_names = {item[1] for item in items_with_ids}  # Mengambil nama item saja dan menghapus duplikat dengan mengubahnya menjadi set

            sorted_item_names = sorted(item_names)  # Sort set items to display

            combo.addItems(sorted_item_names)  # Convert set to list and sort it for better presentation

        except Exception as e:
            print(f"Error populating electric combo ({data_type}): {e}")



    def populate_combo_next_maintenance(self, combo, data_type):
        try:
            combo.clear()
            combo.addItem("All")

            items_with_ids = []
            if data_type == 'labor':
                items_with_ids = self.db_manager.get_all_labor_with_ids()
            elif data_type == 'machine':
                items_with_ids = self.db_manager.get_all_machines_with_ids()
            elif data_type == 'part':
                items_with_ids = self.db_manager.get_all_parts_with_ids()
            else:
                print(f"Unsupported data type: {data_type}")
                return

            item_names = {item[1] for item in items_with_ids}  # Mengambil nama item saja dan menghapus duplikat dengan mengubahnya menjadi set

            sorted_item_names = sorted(item_names)  # Sort set items to display

            combo.addItems(sorted_item_names)  # Convert set to list and sort it for better presentation

        except Exception as e:
            print(f"Error populating combo ({data_type}): {e}")

    def electric_populate_combo_next_maintenance(self, combo, data_type):
        try:
            combo.clear()
            combo.addItem("All")

            items_with_ids = []
            if data_type == 'labor':
                items_with_ids = self.db_manager.electric_get_all_labor_with_ids()
            elif data_type == 'machine':
                items_with_ids = self.db_manager.electric_get_all_machines_with_ids()
            elif data_type == 'part':
                items_with_ids = self.db_manager.electric_get_all_parts_with_ids()
            else:
                print(f"Unsupported data type: {data_type}")
                return

            item_names = {item[1] for item in items_with_ids}  # Mengambil nama item saja dan menghapus duplikat dengan mengubahnya menjadi set

            sorted_item_names = sorted(item_names)  # Sort set items to display

            combo.addItems(sorted_item_names)  # Convert set to list and sort it for better presentation

        except Exception as e:
            print(f"Error populating combo ({data_type}): {e}")

    def populate_combo_history(self, combo, data_type):
        try:
            combo.clear()
            combo.addItem("All")

            items_with_ids = []

            if data_type == 'labor':
                items_with_ids = self.db_manager.get_all_labor_with_ids()
            elif data_type == 'machine':
                items_with_ids = self.db_manager.get_all_machines_with_ids()
            elif data_type == 'part':
                items_with_ids = self.db_manager.get_all_parts_with_ids()
            else:
                print(f"Unsupported data type: {data_type}")
                return

            item_names = {item[1] for item in items_with_ids}  # Mengambil nama item saja dan menghapus duplikat dengan mengubahnya menjadi set

            sorted_item_names = sorted(item_names)  # Sort set items to display

            combo.addItems(sorted_item_names)  # Convert set to list and sort it for better presentation

        except Exception as e:
            print(f"Error populating combo ({data_type}): {e}")

    def electric_populate_combo_history(self, combo, data_type):
        try:
            combo.clear()
            combo.addItem("All")

            items_with_ids = []

            if data_type == 'labor':
                items_with_ids = self.db_manager.electric_get_all_labor_with_ids()
            elif data_type == 'machine':
                items_with_ids = self.db_manager.electric_get_all_machines_with_ids()
            elif data_type == 'part':
                items_with_ids = self.db_manager.electric_get_all_parts_with_ids()
            else:
                print(f"Unsupported data type: {data_type}")
                return

            item_names = {item[1] for item in items_with_ids}  # Mengambil nama item saja dan menghapus duplikat dengan mengubahnya menjadi set

            sorted_item_names = sorted(item_names)  # Sort set items to display

            combo.addItems(sorted_item_names)  # Convert set to list and sort it for better presentation

        except Exception as e:
            print(f"Error populating combo ({data_type}): {e}")


    def setup_machine_tab(self):
        self.layout = QVBoxLayout()
        self.layout.setSpacing(4)
        self.machine_tab.setLayout(self.layout)

        self.form_layout = QFormLayout()
        self.form_layout.setSpacing(4)

        # Menambahkan ComboBox untuk Labor
        self.labor_label = QLabel("Labor")
        self.labor_combo = QComboBox()
        self.labor_combo.addItem("Pilih Area / Labor")  # Menambahkan item default
        self.labor_combo.addItems(["Fiber Preparation", "Utility", "Final Mix", "Laminating", "Dryer", "Finishing"])  # Menambahkan opsi lain
        self.form_layout.addRow(self.labor_label, self.labor_combo)
        self.labor_combo.setMaximumWidth(400)

        self.name_input = QLineEdit()
        self.name_input.setMaximumWidth(400)
        self.form_layout.addRow("Nama Mesin", self.name_input)

        self.bagian_mesin_input = QLineEdit()
        self.bagian_mesin_input.setMaximumWidth(400)
        self.form_layout.addRow("Bagian Mesin", self.bagian_mesin_input)

        self.frequency_pemeriksaan_label = QLabel("Job Frequency")
        self.frequency_pemeriksaan_combo = QComboBox()
        self.frequency_pemeriksaan_combo.addItems(["Pilih Frequency", "1W", "2W", "1M", "3M", "6M", "1Y", "2Y", "3Y", "4Y", "5Y"])
        self.form_layout.addRow(self.frequency_pemeriksaan_label, self.frequency_pemeriksaan_combo)
        self.frequency_pemeriksaan_combo.setMaximumWidth(400)

        self.iterasi_label = QLabel("Iterasi (Tahun)")
        self.iterasi_combo = QComboBox()
        self.iterasi_combo.addItem("Pilih Iterasi")  # Item default
        self.iterasi_combo.addItems(["1", "2", "3", "4", "5"])  # Menambahkan opsi iterasi
        self.form_layout.addRow(self.iterasi_label, self.iterasi_combo)
        self.iterasi_combo.setMaximumWidth(400)

        self.outer_group_box = QGroupBox("Deskripsi")
        self.outer_group_layout = QVBoxLayout()
        self.outer_group_box.setLayout(self.outer_group_layout)

        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.outer_group_layout.addWidget(self.scroll_area)

        self.container_widget = QWidget()
        self.container_layout = QVBoxLayout()
        self.container_widget.setLayout(self.container_layout)
        self.scroll_area.setWidget(self.container_widget)

        self.add_input_fields()

        self.add_entry_button = QPushButton("Add Entry")
        self.add_entry_button.clicked.connect(self.add_entry)

        self.add_details_button = QPushButton("Add Deskripsi")
        self.add_details_button.clicked.connect(self.add_input_fields)

        self.form_layout.addRow(self.outer_group_box)
        self.layout.addLayout(self.form_layout)
        self.layout.addWidget(self.add_details_button)
        self.layout.addWidget(self.add_entry_button)


    def setup_electric_tab(self):
        self.electric_layout = QVBoxLayout()
        self.electric_layout.setSpacing(4)
        self.electric_tab.setLayout(self.electric_layout)

        self.electric_form_layout = QFormLayout()
        self.electric_form_layout.setSpacing(4)

        # Menambahkan ComboBox untuk Labor
        self.electric_labor_label = QLabel("Labor")
        self.electric_labor_combo = QComboBox()
        self.electric_labor_combo.addItem("Pilih Area / Labor")  # Menambahkan item default
        self.electric_labor_combo.addItems(["Fiber Preparation", "Utility", "Final Mix", "Laminating", "Dryer", "Finishing"])  # Menambahkan opsi lain
        self.electric_form_layout.addRow(self.electric_labor_label, self.electric_labor_combo)
        self.electric_labor_combo.setMaximumWidth(400)

        self.electric_name_input = QLineEdit()
        self.electric_name_input.setMaximumWidth(400)
        self.electric_form_layout.addRow("Nama Mesin", self.electric_name_input)

        self.electric_bagian_mesin_input = QLineEdit()
        self.electric_bagian_mesin_input.setMaximumWidth(400)
        self.electric_form_layout.addRow("Bagian Mesin", self.electric_bagian_mesin_input)

        self.electric_frequency_pemeriksaan_label = QLabel("Job Frequency")
        self.electric_frequency_pemeriksaan_combo = QComboBox()
        self.electric_frequency_pemeriksaan_combo.addItems(["Pilih Frequency", "1W", "2W", "1M", "3M", "6M", "1Y", "2Y", "3Y", "4Y", "5Y"])
        self.electric_form_layout.addRow(self.electric_frequency_pemeriksaan_label, self.electric_frequency_pemeriksaan_combo)
        self.electric_frequency_pemeriksaan_combo.setMaximumWidth(400)

        self.electric_iterasi_label = QLabel("Iterasi (Tahun)")
        self.electric_iterasi_combo = QComboBox()
        self.electric_iterasi_combo.addItem("Pilih Iterasi")  # Item default
        self.electric_iterasi_combo.addItems(["1", "2", "3", "4", "5"])  # Menambahkan opsi iterasi
        self.electric_form_layout.addRow(self.electric_iterasi_label, self.electric_iterasi_combo)
        self.electric_iterasi_combo.setMaximumWidth(400)

        self.electric_outer_group_box = QGroupBox("Deskripsi")
        self.electric_outer_group_layout = QVBoxLayout()
        self.electric_outer_group_box.setLayout(self.electric_outer_group_layout)

        self.electric_scroll_area = QScrollArea()
        self.electric_scroll_area.setWidgetResizable(True)
        self.electric_outer_group_layout.addWidget(self.electric_scroll_area)

        self.electric_container_widget = QWidget()
        self.electric_container_layout = QVBoxLayout()
        self.electric_container_widget.setLayout(self.electric_container_layout)
        self.electric_scroll_area.setWidget(self.electric_container_widget)

        self.electric_add_input_fields()  # Anda mungkin perlu mendefinisikan metode ini

        self.electric_add_entry_button = QPushButton("Add Entry")
        self.electric_add_entry_button.clicked.connect(self.electric_add_entry)  # Anda mungkin perlu mendefinisikan metode ini

        self.electric_add_details_button = QPushButton("Add Deskripsi")
        self.electric_add_details_button.clicked.connect(self.electric_add_input_fields)  # Anda mungkin perlu mendefinisikan metode ini

        self.electric_form_layout.addRow(self.electric_outer_group_box)
        self.electric_layout.addLayout(self.electric_form_layout)
        self.electric_layout.addWidget(self.electric_add_details_button)
        self.electric_layout.addWidget(self.electric_add_entry_button)


    def add_input_fields(self):
        try:
            
            inner_group_box = QGroupBox("Inner Frame")
            main_layout = QVBoxLayout()

            # Membuat layout horizontal untuk Deskripsi Pemeriksaan dan tombol delete
            top_layout = QHBoxLayout()

            details_label = QLabel("Job Activity          ")
            details_input = QLineEdit()
            details_input.setFixedWidth(400)  # Mengatur lebar tetap

            # Menambahkan spacer untuk memberikan jarak antara input dan tombol delete
            spacer = QSpacerItem(20, 20, QSizePolicy.Expanding, QSizePolicy.Minimum)

            delete_button = QPushButton("Delete")
            delete_button.setFixedSize(60, 25)
            delete_button.clicked.connect(lambda: self.delete_inner_frame(inner_group_box))

            top_layout.addWidget(details_label)
            top_layout.addWidget(details_input)
            top_layout.addItem(spacer)  # Menambahkan spacer ke dalam layout
            top_layout.addWidget(delete_button)

            main_layout.addLayout(top_layout)

            # Membuat layout form untuk input fields lainnya
            form_layout = QFormLayout()

            spare_part_input = QLineEdit()
            spare_part_input.setFixedWidth(400)  # Mengatur lebar tetap
            form_layout.addRow("Spare Part", spare_part_input)

            standard_input = QLineEdit()
            standard_input.setFixedWidth(400)  # Mengatur lebar tetap
            form_layout.addRow("Standard", standard_input)

            part_number_input = QLineEdit()
            part_number_input.setFixedWidth(400)  # Mengatur lebar tetap
            form_layout.addRow("Part Number", part_number_input)

            # Menambahkan input field untuk Maintenance Date
            maintenance_date_input = QDateEdit()
            maintenance_date_input.setFixedWidth(400)  # Mengatur lebar tetap
            maintenance_date_input.setCalendarPopup(True)  # Menampilkan popup kalender
            maintenance_date_input.setDate(QDate.currentDate())  # Set tanggal ke hari ini
            form_layout.addRow("Maintenance Date", maintenance_date_input)

            main_layout.addLayout(form_layout)
            inner_group_box.setLayout(main_layout)

            self.container_layout.addWidget(inner_group_box)

            # Menyimpan referensi input fields jika diperlukan
            self.details_inputs.append(details_input)
            self.standard_inputs.append(standard_input)
            self.spare_part_inputs.append(spare_part_input)
            self.part_number_inputs.append(part_number_input)
            self.maintenance_date_inputs.append(maintenance_date_input)  # Menyimpan referensi input tanggal

            # Menambahkan pernyataan cetak untuk debugging
            print("Details Inputs:", [input.text() for input in self.details_inputs])
            print("Standard Inputs:", [input.text() for input in self.standard_inputs])
            print("Spare Part Inputs:", [input.text() for input in self.spare_part_inputs])
            print("Part Number Inputs:", [input.text() for input in self.part_number_inputs])
            print("Maintenance Date Inputs:", [
                input.date().toString()
                for input in self.maintenance_date_inputs
                if not sip.isdeleted(input)  # Tambahkan pemeriksaan ini
            ])  # Menampilkan tanggal

            # Ini adalah baris kode baru untuk mencetak nilai saat ini dari self.maintenance_date_inputs
            for i, date_input in enumerate(self.maintenance_date_inputs):
                if not sip.isdeleted(date_input):
                    print(f"Maintenance Date Input {i}: {date_input.date().toString()}")
                else:
                    print(f"Maintenance Date Input {i} has been deleted")

        except Exception as e:
            print("Error in add_input_fields:", e)
            import traceback
            print(traceback.format_exc())  # Ini akan mencetak stack trace untuk memberikan konteks error


    def electric_add_input_fields(self):
        try:
            
            electric_inner_group_box = QGroupBox("Inner Frame")
            electric_main_layout = QVBoxLayout()

            # Membuat layout horizontal untuk Deskripsi Pemeriksaan dan tombol delete
            electric_top_layout = QHBoxLayout()

            electric_details_label = QLabel("Job Activity          ")
            electric_details_input = QLineEdit()
            electric_details_input.setFixedWidth(400)  # Mengatur lebar tetap

            # Menambahkan spacer untuk memberikan jarak antara input dan tombol delete
            electric_spacer = QSpacerItem(20, 20, QSizePolicy.Expanding, QSizePolicy.Minimum)

            electric_delete_button = QPushButton("Delete")
            electric_delete_button.setFixedSize(60, 25)
            electric_delete_button.clicked.connect(lambda: self.electric_delete_inner_frame(electric_inner_group_box))

            electric_top_layout.addWidget(electric_details_label)
            electric_top_layout.addWidget(electric_details_input)
            electric_top_layout.addItem(electric_spacer)  # Menambahkan spacer ke dalam layout
            electric_top_layout.addWidget(electric_delete_button)

            electric_main_layout.addLayout(electric_top_layout)

            # Membuat layout form untuk input fields lainnya
            electric_form_layout = QFormLayout()

            electric_spare_part_input = QLineEdit()
            electric_spare_part_input.setFixedWidth(400)  # Mengatur lebar tetap
            electric_form_layout.addRow("Spare Part", electric_spare_part_input)

            electric_standard_input = QLineEdit()
            electric_standard_input.setFixedWidth(400)  # Mengatur lebar tetap
            electric_form_layout.addRow("Standard", electric_standard_input)

            electric_part_number_input = QLineEdit()
            electric_part_number_input.setFixedWidth(400)  # Mengatur lebar tetap
            electric_form_layout.addRow("Part Number", electric_part_number_input)

            # Menambahkan input field untuk Maintenance Date
            electric_maintenance_date_input = QDateEdit()
            electric_maintenance_date_input.setFixedWidth(400)  # Mengatur lebar tetap
            electric_maintenance_date_input.setCalendarPopup(True)  # Menampilkan popup kalender
            electric_maintenance_date_input.setDate(QDate.currentDate())  # Set tanggal ke hari ini
            electric_form_layout.addRow("Maintenance Date", electric_maintenance_date_input)

            electric_main_layout.addLayout(electric_form_layout)
            electric_inner_group_box.setLayout(electric_main_layout)

            self.electric_container_layout.addWidget(electric_inner_group_box)

            # Menyimpan referensi input fields jika diperlukan
            self.electric_details_inputs.append(electric_details_input)
            self.electric_standard_inputs.append(electric_standard_input)
            self.electric_spare_part_inputs.append(electric_spare_part_input)
            self.electric_part_number_inputs.append(electric_part_number_input)
            self.electric_maintenance_date_inputs.append(electric_maintenance_date_input)  # Menyimpan referensi input tanggal

            # Menambahkan pernyataan cetak untuk debugging
            print("Electric Details Inputs:", [input.text() for input in self.electric_details_inputs])
            print("Electric Standard Inputs:", [input.text() for input in self.electric_standard_inputs])
            print("Electric Spare Part Inputs:", [input.text() for input in self.electric_spare_part_inputs])
            print("Electric Part Number Inputs:", [input.text() for input in self.electric_part_number_inputs])
            print("Electric Maintenance Date Inputs:", [
                input.date().toString()
                for input in self.electric_maintenance_date_inputs
                if not sip.isdeleted(input)  # Tambahkan pemeriksaan ini
            ])  # Menampilkan tanggal

        except Exception as e:
            print("Error in electric_add_input_fields:", e)
            import traceback
            print(traceback.format_exc())  # Ini akan mencetak stack trace untuk memberikan konteks error


    def setup_output_tab(self):
        # Setup layout
        self.layout = QVBoxLayout()
        self.output_tab.setLayout(self.layout)

        # Create combo boxes for filtering
        filter_layout = QHBoxLayout()

        self.search_by_labor_combo_output = QComboBox()
        self.search_by_labor_combo_output.addItem("All")
        self.search_by_labor_combo_output.currentIndexChanged.connect(self.apply_filters)
        filter_layout.addWidget(QLabel("Search by Labor:"))
        filter_layout.addWidget(self.search_by_labor_combo_output)

        self.search_by_name_combo_output = QComboBox()
        self.search_by_name_combo_output.addItem("All")
        self.search_by_name_combo_output.currentIndexChanged.connect(self.apply_filters)
        filter_layout.addWidget(QLabel("Search by Nama Mesin:"))
        filter_layout.addWidget(self.search_by_name_combo_output)

        self.search_by_part_combo_output = QComboBox()
        self.search_by_part_combo_output.addItem("All")
        self.search_by_part_combo_output.currentIndexChanged.connect(self.apply_filters)
        filter_layout.addWidget(QLabel("Search by Bagian Mesin:"))
        filter_layout.addWidget(self.search_by_part_combo_output)

        # Menambahkan combo box untuk filter job deskripsi
        self.search_by_job_activity_combo_output = QComboBox()
        self.search_by_job_activity_combo_output.addItem("All")
        self.search_by_job_activity_combo_output.addItems(["Periksa", "Ganti", "Bersihkan", "Kencangkan", "Sejajarkan", "Lubrikasi"])
        self.search_by_job_activity_combo_output.currentIndexChanged.connect(self.apply_filters)
        filter_layout.addWidget(QLabel("Search by Job Activity:"))
        filter_layout.addWidget(self.search_by_job_activity_combo_output)

        # Adding combo box for part number filter
        self.search_by_part_number_combo_output = QComboBox()
        self.search_by_part_number_combo_output.addItem("All")
        self.search_by_part_number_combo_output.addItems(["With Part Number", "Only N/A"])
        self.search_by_part_number_combo_output.currentIndexChanged.connect(self.apply_filters)
        filter_layout.addWidget(QLabel("Search by Part Number:"))
        filter_layout.addWidget(self.search_by_part_number_combo_output)

        self.search_by_month_combo_output = QComboBox()
        self.search_by_month_combo_output.addItem("All")
        self.search_by_month_combo_output.addItems(["January", "February", "March", "April", "May", "June",
                                                "July", "August", "September", "October", "November", "December"])
        self.search_by_month_combo_output.currentIndexChanged.connect(self.apply_filters)
        filter_layout.addWidget(QLabel("Search by Month:"))
        filter_layout.addWidget(self.search_by_month_combo_output)


        self.layout.addLayout(filter_layout)

        # Button untuk membuka tab "Output Electric"
        self.new_tab_button = QPushButton("Open Output Electric Tab")
        self.new_tab_button.clicked.connect(self.add_output_electric_tab)
        self.layout.addWidget(self.new_tab_button)

        # Tabel output
        self.table = CustomTableWidget()
        self.table.setColumnCount(12)  # Menambahkan satu kolom lagi untuk "Labor"
        self.table.setHorizontalHeaderLabels(["Labor", "Nama Mesin", "Bagian Mesin", "Job Frequency", "Job Activity", "Spare Part",
                                            "Part Number", "Standard", "Date", "Next PM", "Status", "Action"])  # Menambahkan label "Labor"
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.layout.addWidget(self.table)

        self.navigationLayout = QHBoxLayout()

        self.prev_button = QPushButton('Previous')
        self.prev_button.clicked.connect(self.prev_page)
        self.prev_button.setFixedHeight(30)  
        self.prev_button.setFixedWidth(400)  # Menetapkan lebar tombol menjadi 400px
        self.navigationLayout.addWidget(self.prev_button)

        self.navigationLayout.addStretch(1)  # Menambahkan stretch sebelum page_label

        self.page_label = QLabel('Page 1')
        self.navigationLayout.addWidget(self.page_label)

        self.navigationLayout.addStretch(1)  # Menambahkan stretch setelah page_label

        self.next_button = QPushButton('Next')
        self.next_button.clicked.connect(self.next_page)
        self.next_button.setFixedHeight(30) 
        self.next_button.setFixedWidth(400)  # Menetapkan lebar tombol menjadi 400px
        self.navigationLayout.addWidget(self.next_button)

        self.layout.addLayout(self.navigationLayout)

        # Hubungkan sinyal itemClicked dengan metode on_status_clicked
        self.table.itemClicked.connect(self.on_status_button_clicked)

        # Update the filter combos with distinct values from the database (if needed)
        self.populate_combo_output(self.search_by_labor_combo_output, 'labor')
        self.populate_combo_output(self.search_by_name_combo_output, 'machine')
        self.populate_combo_output(self.search_by_part_combo_output, 'part')

    def electric_setup_output_tab(self):
        # Setup layout
        self.electric_layout = QVBoxLayout()
        self.output_electric_tab.setLayout(self.electric_layout)

        # Create combo boxes for filtering
        electric_filter_layout = QHBoxLayout()

        self.electric_search_by_labor_combo_output = QComboBox()
        self.electric_search_by_labor_combo_output.addItem("All")
        self.electric_search_by_labor_combo_output.currentIndexChanged.connect(self.electric_apply_filters)
        electric_filter_layout.addWidget(QLabel("Search by Labor:"))
        electric_filter_layout.addWidget(self.electric_search_by_labor_combo_output)

        self.electric_search_by_name_combo_output = QComboBox()
        self.electric_search_by_name_combo_output.addItem("All")
        self.electric_search_by_name_combo_output.currentIndexChanged.connect(self.electric_apply_filters)
        electric_filter_layout.addWidget(QLabel("Search by Nama Mesin:"))
        electric_filter_layout.addWidget(self.electric_search_by_name_combo_output)

        self.electric_search_by_part_combo_output = QComboBox()
        self.electric_search_by_part_combo_output.addItem("All")
        self.electric_search_by_part_combo_output.currentIndexChanged.connect(self.electric_apply_filters)
        electric_filter_layout.addWidget(QLabel("Search by Bagian Mesin:"))
        electric_filter_layout.addWidget(self.electric_search_by_part_combo_output)

        self.electric_search_by_job_activity_combo_output = QComboBox()
        self.electric_search_by_job_activity_combo_output.addItem("All")
        self.electric_search_by_job_activity_combo_output.addItems(["Periksa", "Ganti", "Bersihkan", "Kencangkan", "Sejajarkan", "Lubrikasi"])
        self.electric_search_by_job_activity_combo_output.currentIndexChanged.connect(self.electric_apply_filters)
        electric_filter_layout.addWidget(QLabel("Search by Job Activity:"))
        electric_filter_layout.addWidget(self.electric_search_by_job_activity_combo_output)

        self.electric_search_by_part_number_combo_output = QComboBox()
        self.electric_search_by_part_number_combo_output.addItem("All")
        self.electric_search_by_part_number_combo_output.addItems(["With Part Number", "Only N/A"])
        self.electric_search_by_part_number_combo_output.currentIndexChanged.connect(self.electric_apply_filters)
        electric_filter_layout.addWidget(QLabel("Search by Part Number:"))
        electric_filter_layout.addWidget(self.electric_search_by_part_number_combo_output)

        self.electric_search_by_month_combo_output = QComboBox()
        self.electric_search_by_month_combo_output.addItem("All")
        self.electric_search_by_month_combo_output.addItems(["January", "February", "March", "April", "May", "June",
                                                            "July", "August", "September", "October", "November", "December"])
        self.electric_search_by_month_combo_output.currentIndexChanged.connect(self.electric_apply_filters)
        electric_filter_layout.addWidget(QLabel("Search by Month:"))
        electric_filter_layout.addWidget(self.electric_search_by_month_combo_output)

        self.electric_layout.addLayout(electric_filter_layout)

        # Tabel output
        self.electric_table = CustomTableWidget()
        self.electric_table.setColumnCount(12)  # Menambahkan satu kolom lagi untuk "Labor"
        self.electric_table.setHorizontalHeaderLabels(["Labor", "Nama Mesin", "Bagian Mesin", "Job Frequency", "Job Activity", "Spare Part",
                                                    "Part Number", "Standard", "Date", "Next PM", "Status", "Action"])  # Menambahkan label "Labor"
        self.electric_table.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.electric_layout.addWidget(self.electric_table)

        self.electric_navigationLayout = QHBoxLayout()

        self.electric_prev_button = QPushButton('Previous')
        self.electric_prev_button.clicked.connect(self.electric_prev_page)
        self.electric_navigationLayout.addWidget(self.electric_prev_button)
        self.electric_prev_button.setFixedHeight(30)  
        self.electric_prev_button.setFixedWidth(400)  # Menetapkan lebar tombol menjadi 400px
        self.navigationLayout.addWidget(self.electric_prev_button)

        self.electric_navigationLayout.addStretch(1)  # Menambahkan stretch sebelum page_label

        self.electric_page_label = QLabel('Page 1')
        self.electric_navigationLayout.addWidget(self.electric_page_label)

        self.electric_navigationLayout.addStretch(1)  # Menambahkan stretch sebelum page_label

        self.electric_next_button = QPushButton('Next')
        self.electric_next_button.clicked.connect(self.electric_next_page)
        self.electric_navigationLayout.addWidget(self.electric_next_button)
        self.electric_next_button.setFixedHeight(30)  
        self.electric_next_button.setFixedWidth(400)  # Menetapkan lebar tombol menjadi 400px
        self.navigationLayout.addWidget(self.electric_next_button)

        self.electric_layout.addLayout(self.electric_navigationLayout)

        # Hubungkan sinyal itemClicked dengan metode on_status_clicked
        self.electric_table.itemClicked.connect(self.electric_on_status_button_clicked)

        # Update the filter combos with distinct values from the database (if needed)
        self.electric_populate_combo_output(self.electric_search_by_labor_combo_output, 'labor')
        self.electric_populate_combo_output(self.electric_search_by_name_combo_output, 'machine')
        self.electric_populate_combo_output(self.electric_search_by_part_combo_output, 'part')


    def add_output_electric_tab(self):
        # Pindah ke tab "Output Electric"
        self.central_widget.setCurrentWidget(self.output_electric_tab)

    def add_history_electric_tab(self):
        # Pindah ke tab "Output Electric"
        self.central_widget.setCurrentWidget(self.electric_history_tab)

    def go_to_output_tab(self):
        self.central_widget.setCurrentWidget(self.output_tab)

    def setup_next_maintenance_tab(self):
        self.layout = QVBoxLayout()
        self.next_maintenance_tab.setLayout(self.layout)

        # Membuat layout horizontal untuk filter
        self.filter_layout = QHBoxLayout()

        self.print_button = QPushButton("Print / Hard Copy")
        self.print_button.clicked.connect(self.print_next_maintenance)
        self.layout.addWidget(self.print_button)

        # Membuat QComboBox untuk labor
        self.search_by_labor_combo = QComboBox()
        self.filter_layout.addWidget(QLabel("Search by Labor:"))
        self.filter_layout.addWidget(self.search_by_labor_combo)

        # Membuat QComboBox untuk nama mesin
        self.search_by_name_combo = QComboBox()
        self.filter_layout.addWidget(QLabel("Search by Nama Mesin:"))
        self.filter_layout.addWidget(self.search_by_name_combo)

        # Membuat QComboBox untuk bagian mesin
        self.search_by_part_combo = QComboBox()
        self.filter_layout.addWidget(QLabel("Search by Bagian Mesin:"))
        self.filter_layout.addWidget(self.search_by_part_combo)

        self.month_filter_combo = QComboBox()
        self.month_filter_combo.addItem("All")
        self.month_filter_combo.addItems(["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"])
        # Add Specific Date option here
        self.month_filter_combo.addItem("Specific Date")
        self.month_filter_combo.currentIndexChanged[str].connect(self.handle_month_combo_change)
        
        self.filter_layout.addWidget(QLabel("Search by Month:"))
        self.filter_layout.addWidget(self.month_filter_combo)

        # Connect the combo box change to a new method that will handle the Specific Date option
        self.month_filter_combo.currentIndexChanged.connect(self.handle_month_combo_change)

        # Menambahkan layout filter ke layout utama
        self.layout.addLayout(self.filter_layout)

                # Menambahkan tombol ke layout
        self.open_next_maintenance_electric_button = QPushButton("Open Next Maintenance Electric Tab")
        self.open_next_maintenance_electric_button.clicked.connect(self.open_next_maintenance_electric)
        self.layout.addWidget(self.open_next_maintenance_electric_button)

        # Membuat QTableWidget
        self.next_maintenance_table = CustomTableWidget()
        self.next_maintenance_table.itemClicked.connect(self.on_status_button_clicked)
        self.next_maintenance_table.setColumnCount(14)  # Update to 14 to include "Checklist" and "Comment" columns
        self.next_maintenance_table.setHorizontalHeaderLabels(["Labor", "Nama Mesin", "Bagian Mesin", "Job Frequency", "Job Activity", "Spare Part", "Part Number", "Standard", "Checklist", "Comment", "Date", "Next PM", "Status", "Action"])  # Add "Checklist" and "Comment"
        self.next_maintenance_table.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.layout.addWidget(self.next_maintenance_table)

        # Hubungkan QComboBox dengan metode filter yang sesuai
        self.search_by_labor_combo.currentIndexChanged.connect(self.apply_filters_next_maintenance)
        self.search_by_name_combo.currentIndexChanged.connect(self.apply_filters_next_maintenance)
        self.search_by_part_combo.currentIndexChanged.connect(self.apply_filters_next_maintenance)
        self.month_filter_combo.currentIndexChanged.connect(self.apply_filters_next_maintenance)

        # Mengisi QComboBox dengan data
        self.populate_combo_next_maintenance(self.search_by_labor_combo, 'labor')
        self.populate_combo_next_maintenance(self.search_by_name_combo, 'machine')
        self.populate_combo_next_maintenance(self.search_by_part_combo, 'part')




    def setup_next_maintenance_electric_tab(self):
        self.electric_layout = QVBoxLayout()
        self.next_maintenance_electric_tab.setLayout(self.electric_layout)

        # Membuat layout horizontal untuk filter
        self.electric_filter_layout = QHBoxLayout()

        # Membuat QComboBox untuk labor
        self.electric_search_by_labor_combo = QComboBox()
        self.electric_filter_layout.addWidget(QLabel("Search by Labor:"))
        self.electric_filter_layout.addWidget(self.electric_search_by_labor_combo)

        # Membuat QComboBox untuk nama mesin
        self.electric_search_by_name_combo = QComboBox()
        self.electric_filter_layout.addWidget(QLabel("Search by Nama Mesin:"))
        self.electric_filter_layout.addWidget(self.electric_search_by_name_combo)

        # Membuat QComboBox untuk bagian mesin
        self.electric_search_by_part_combo = QComboBox()
        self.electric_filter_layout.addWidget(QLabel("Search by Bagian Mesin:"))
        self.electric_filter_layout.addWidget(self.electric_search_by_part_combo)

        # Membuat QComboBox untuk bulan
        self.electric_month_filter_combo = QComboBox()
        self.electric_month_filter_combo.addItem("All")
        self.electric_month_filter_combo.addItems(["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"])
        self.electric_filter_layout.addWidget(QLabel("Search by Month:"))
        self.electric_filter_layout.addWidget(self.electric_month_filter_combo)

        # Menambahkan layout filter ke layout utama
        self.electric_layout.addLayout(self.electric_filter_layout)

        # Membuat QTableWidget
        self.electric_next_maintenance_table = CustomTableWidget()
        self.electric_next_maintenance_table.itemClicked.connect(self.electric_on_status_button_clicked)
        self.electric_next_maintenance_table.setColumnCount(12)
        self.electric_next_maintenance_table.setHorizontalHeaderLabels(["Labor", "Nama Mesin", "Bagian Mesin", "Job Frequency", "Job Activity", "Spare Part", "Part Number", "Standard", "Date", "Next PM", "Status", "Action"])
        self.electric_next_maintenance_table.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.electric_layout.addWidget(self.electric_next_maintenance_table)

        # Hubungkan QComboBox dengan metode filter yang sesuai
        self.electric_search_by_labor_combo.currentIndexChanged.connect(self.electric_apply_filters_next_maintenance)
        self.electric_search_by_name_combo.currentIndexChanged.connect(self.electric_apply_filters_next_maintenance)
        self.electric_search_by_part_combo.currentIndexChanged.connect(self.electric_apply_filters_next_maintenance)
        self.electric_month_filter_combo.currentIndexChanged.connect(self.electric_apply_filters_next_maintenance)

                # Mengisi QComboBox dengan data
        self.electric_populate_combo_next_maintenance(self.electric_search_by_labor_combo, 'labor')
        self.electric_populate_combo_next_maintenance(self.electric_search_by_name_combo, 'machine')
        self.electric_populate_combo_next_maintenance(self.electric_search_by_part_combo, 'part')

    def setup_history_tab(self):
        self.history_layout = QVBoxLayout()
        self.history_tab.setLayout(self.history_layout)

        # Create combo boxes for filtering
        filter_layout = QHBoxLayout()
        
        # Membuat QComboBox untuk labor
        self.search_by_labor_combo_history = QComboBox()
        self.search_by_labor_combo_history.addItem("All")
        self.search_by_labor_combo_history.currentIndexChanged.connect(self.apply_filters_history)
        filter_layout.addWidget(QLabel("Search by Labor:"))
        filter_layout.addWidget(self.search_by_labor_combo_history)

        self.search_by_name_combo_history = QComboBox()
        self.search_by_name_combo_history.addItem("All")
        self.search_by_name_combo_history.currentIndexChanged.connect(self.apply_filters_history)
        filter_layout.addWidget(QLabel("Search by Nama Mesin:"))
        filter_layout.addWidget(self.search_by_name_combo_history)

        self.search_by_part_combo_history = QComboBox()
        self.search_by_part_combo_history.addItem("All")
        self.search_by_part_combo_history.currentIndexChanged.connect(self.apply_filters_history)
        filter_layout.addWidget(QLabel("Search by Bagian Mesin:"))
        filter_layout.addWidget(self.search_by_part_combo_history)

        self.search_by_month_combo_history = QComboBox()
        self.search_by_month_combo_history.addItem("All")
        self.search_by_month_combo_history.addItems(["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"])
        self.search_by_month_combo_history.currentIndexChanged.connect(self.apply_filters_history)
        filter_layout.addWidget(QLabel("Search by Month:"))
        filter_layout.addWidget(self.search_by_month_combo_history)

        # Menambahkan combo box untuk filter job deskripsi
        self.search_by_job_activity_combo_history = QComboBox()
        self.search_by_job_activity_combo_history.addItem("All")
        self.search_by_job_activity_combo_history.addItems(["Periksa", "Ganti", "Bersihkan", "Kencangkan", "Sejajarkan", "Lubrikasi"])
        self.search_by_job_activity_combo_history.currentIndexChanged.connect(self.apply_filters_history)
        filter_layout.addWidget(QLabel("Search by Job Activity:"))
        filter_layout.addWidget(self.search_by_job_activity_combo_history)

        # Menambahkan combo box untuk filter nomor bagian
        self.search_by_part_number_combo_history = QComboBox()
        self.search_by_part_number_combo_history.addItem("All")
        self.search_by_part_number_combo_history.addItems(["With Part Number", "Only N/A"])
        self.search_by_part_number_combo_history.currentIndexChanged.connect(self.apply_filters_history)
        filter_layout.addWidget(QLabel("Search by Part Number:"))
        filter_layout.addWidget(self.search_by_part_number_combo_history)

        self.history_layout.addLayout(filter_layout)

        # Button untuk membuka tab "Output Electric"
        self.electric_history_tab_button = QPushButton("Open History Electric Tab")
        self.electric_history_tab_button.clicked.connect(self.add_history_electric_tab)
        self.history_layout.addWidget(self.electric_history_tab_button)

        # History Table
        self.history_table = CustomTableWidget()
        self.history_table.setColumnCount(13)  # Increase the count to include new columns
        self.history_table.setHorizontalHeaderLabels(
            ["Labor", "Nama Mesin", "Bagian Mesin", "Frequency Pemeriksaan", "Deskripsi Pemeriksaan",
             "Spare Part", "Part Number", "Standard", "Checklist", "Comment", "Date", "Completed Date", "Status"]
        )
        self.history_table.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.history_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.history_table.itemClicked.connect(self.on_status_button_clicked)  # Assuming you have or will have this method
        self.history_layout.addWidget(self.history_table)

        # Initially populate the combo boxes with data
        self.populate_combo_history(self.search_by_labor_combo_history, 'labor')
        self.populate_combo_history(self.search_by_name_combo_history, 'machine')
        self.populate_combo_history(self.search_by_part_combo_history, 'part')

        # Populate the history table with data (you can add this function)
        self.populate_history_tab()

        self.history_navigation_layout = QHBoxLayout()

        self.prev_button_history = QPushButton('Previous')
        self.prev_button_history.clicked.connect(self.prev_page_history)
        self.prev_button_history.setFixedHeight(30)  
        self.prev_button_history.setFixedWidth(400)  # Menetapkan lebar tombol menjadi 400px
        self.history_navigation_layout.addWidget(self.prev_button_history)

        self.history_navigation_layout.addStretch(1)  # Menambahkan stretch sebelum page_label
  
        self.page_label_history = QLabel('Page 1')
        self.history_navigation_layout.addWidget(self.page_label_history)

        self.history_navigation_layout.addStretch(1)  # Menambahkan stretch sebelum page_label

        self.next_button_history = QPushButton('Next')
        self.next_button_history.clicked.connect(self.next_page_history)
        self.next_button_history.setFixedHeight(30)  
        self.next_button_history.setFixedWidth(400)  # Menetapkan lebar tombol menjadi 400px
        self.history_navigation_layout.addWidget(self.next_button_history)

        self.history_layout.addLayout(self.history_navigation_layout)

    def electric_setup_history_tab(self):
        self.electric_history_layout = QVBoxLayout()
        self.electric_history_tab.setLayout(self.electric_history_layout)

        # Create combo boxes for filtering
        filter_layout = QHBoxLayout()

        # Membuat QComboBox untuk labor
        self.electric_search_by_labor_combo_history = QComboBox()
        self.electric_search_by_labor_combo_history.addItem("All")
        self.electric_search_by_labor_combo_history.currentIndexChanged.connect(self.electric_apply_filters_history)
        filter_layout.addWidget(QLabel("Search by Labor:"))
        filter_layout.addWidget(self.electric_search_by_labor_combo_history)

        self.electric_search_by_name_combo_history = QComboBox()
        self.electric_search_by_name_combo_history.addItem("All")
        self.electric_search_by_name_combo_history.currentIndexChanged.connect(self.electric_apply_filters_history)
        filter_layout.addWidget(QLabel("Search by Nama Mesin:"))
        filter_layout.addWidget(self.electric_search_by_name_combo_history)

        self.electric_search_by_part_combo_history = QComboBox()
        self.electric_search_by_part_combo_history.addItem("All")
        self.electric_search_by_part_combo_history.currentIndexChanged.connect(self.electric_apply_filters_history)
        filter_layout.addWidget(QLabel("Search by Bagian Mesin:"))
        filter_layout.addWidget(self.electric_search_by_part_combo_history)

        # Menambahkan combo box untuk filter job deskripsi
        self.electric_search_by_job_activity_combo_history = QComboBox()
        self.electric_search_by_job_activity_combo_history.addItem("All")
        self.electric_search_by_job_activity_combo_history.addItems(["Periksa", "Ganti", "Bersihkan", "Kencangkan", "Sejajarkan", "Lubrikasi"])
        self.electric_search_by_job_activity_combo_history.currentIndexChanged.connect(self.electric_apply_filters_history)
        filter_layout.addWidget(QLabel("Search by Job Activity:"))
        filter_layout.addWidget(self.electric_search_by_job_activity_combo_history)

        # Menambahkan combo box untuk filter nomor bagian
        self.electric_search_by_part_number_combo_history = QComboBox()
        self.electric_search_by_part_number_combo_history.addItem("All")
        self.electric_search_by_part_number_combo_history.addItems(["With Part Number", "Only N/A"])
        self.electric_search_by_part_number_combo_history.currentIndexChanged.connect(self.electric_apply_filters_history)
        filter_layout.addWidget(QLabel("Search by Part Number:"))
        filter_layout.addWidget(self.electric_search_by_part_number_combo_history)

        self.electric_search_by_month_combo_history = QComboBox()
        self.electric_search_by_month_combo_history.addItem("All")
        self.electric_search_by_month_combo_history.addItems(["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"])
        self.electric_search_by_month_combo_history.currentIndexChanged.connect(self.electric_apply_filters_history)
        filter_layout.addWidget(QLabel("Search by Month:"))
        filter_layout.addWidget(self.electric_search_by_month_combo_history)

        self.electric_history_layout.addLayout(filter_layout)

        # History Table
        self.electric_history_table = CustomTableWidget()
        self.electric_history_table.setColumnCount(11)
        self.electric_history_table.setHorizontalHeaderLabels(["Labor", "Nama Mesin", "Bagian Mesin", "Frequency Pemeriksaan", "Deskripsi Pemeriksaan", "Spare Part", "Part Number", "Standard", "Date", "Completed Date", "Status"])
        self.electric_history_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.electric_history_table.itemClicked.connect(self.electric_on_status_button_clicked)  # Assuming you have or will have this method
        self.electric_history_layout.addWidget(self.electric_history_table)

        # Initially populate the combo boxes with data
        self.electric_populate_combo_history(self.electric_search_by_labor_combo_history, 'labor')
        self.electric_populate_combo_history(self.electric_search_by_name_combo_history, 'machine')
        self.electric_populate_combo_history(self.electric_search_by_part_combo_history, 'part')

        # Populate the history table with data (you can add this function)
        self.electric_populate_history_tab()

        self.electric_history_navigation_layout = QHBoxLayout()

        self.electric_prev_button_history = QPushButton('Previous')
        self.electric_prev_button_history.clicked.connect(self.electric_prev_page_history)
        self.electric_prev_button_history.setFixedHeight(30)  
        self.electric_prev_button_history.setFixedWidth(400)  # Menetapkan lebar tombol menjadi 400px
        self.electric_history_navigation_layout.addWidget(self.electric_prev_button_history)

        self.electric_history_navigation_layout.addStretch(1)  # Menambahkan stretch sebelum page_label
  
        self.electric_page_label_history = QLabel('Page 1')
        self.electric_history_navigation_layout.addWidget(self.electric_page_label_history)

        self.electric_history_navigation_layout.addStretch(1)  # Menambahkan stretch sebelum page_label

        self.electric_next_button_history = QPushButton('Next')
        self.electric_next_button_history.clicked.connect(self.electric_next_page_history)
        self.electric_next_button_history.setFixedHeight(30)  
        self.electric_next_button_history.setFixedWidth(400)  # Menetapkan lebar tombol menjadi 400px
        self.electric_history_navigation_layout.addWidget(self.electric_next_button_history)

        self.electric_history_layout.addLayout(self.electric_history_navigation_layout)

    def open_next_maintenance_electric(self):
      self.central_widget.setCurrentWidget(self.next_maintenance_electric_tab)

    def handle_month_combo_change(self, selected_option):
        if selected_option == "Specific Date":
            self.present_calendar()

    def present_calendar(self):
        if hasattr(self, 'calendar') and self.calendar.isVisible():
            return

        self.calendar = QCalendarWidget()
        self.calendar.setGridVisible(True)
        self.calendar.clicked[QDate].connect(self.perform_date_filter)
        self.calendar.show()

    def perform_date_filter(self, date):
        formatted_date = date.toString("yyyy-MM-dd")

        for row in range(self.next_maintenance_table.rowCount()):
            date_item = self.next_maintenance_table.item(row, 11)
            self.next_maintenance_table.setRowHidden(row, date_item.text() != formatted_date)

        self.calendar.close()

    def apply_filters(self):
        try:
            selected_labor_output = self.search_by_labor_combo_output.currentText()
            selected_name_output = self.search_by_name_combo_output.currentText()
            selected_part_output = self.search_by_part_combo_output.currentText()
            selected_month_output = self.search_by_month_combo_output.currentText()
            selected_part_number_output = self.search_by_part_number_combo_output.currentText()
            selected_job_activity_output = self.search_by_job_activity_combo_output.currentText()

            filter_conditions = []
            if selected_labor_output != "All":
                filter_conditions.append(f"labor = '{selected_labor_output}'")
            if selected_name_output != "All":
                filter_conditions.append(f"name = '{selected_name_output}'")
            if selected_part_output != "All":
                filter_conditions.append(f"bagian_mesin = '{selected_part_output}'")
            if selected_month_output != "All":
                month_number = datetime.datetime.strptime(selected_month_output, '%B').month
                filter_conditions.append(f"MONTH(next_maintenance_date) = {month_number}")
            if selected_part_number_output != "All":
                if selected_part_number_output == "With Part Number":
                    filter_conditions.append(f"part_number != 'N/A'")
                else:
                    filter_conditions.append(f"part_number = 'N/A'")
            if selected_job_activity_output != "All":
                filter_conditions.append(f"deskripsi LIKE '%{selected_job_activity_output}%'")

            self.last_filter_conditions = filter_conditions  # simpan kondisi filter terakhir
            self.update_output_with_filter_conditions()

        except Exception as e:
            print("Error in apply_filters:", e)
            import traceback
            print(traceback.format_exc())

    def electric_apply_filters(self):
        try:
            selected_labor_output = self.electric_search_by_labor_combo_output.currentText()
            selected_name_output = self.electric_search_by_name_combo_output.currentText()
            selected_part_output = self.electric_search_by_part_combo_output.currentText()
            selected_month_output = self.electric_search_by_month_combo_output.currentText()
            selected_part_number_output = self.electric_search_by_part_number_combo_output.currentText()
            selected_job_activity_output = self.electric_search_by_job_activity_combo_output.currentText()

            filter_conditions = []
            if selected_labor_output != "All":
                filter_conditions.append(f"labor = '{selected_labor_output}'")
            if selected_name_output != "All":
                filter_conditions.append(f"name = '{selected_name_output}'")
            if selected_part_output != "All":
                filter_conditions.append(f"bagian_mesin = '{selected_part_output}'")
            if selected_month_output != "All":
                month_number = datetime.datetime.strptime(selected_month_output, '%B').month
                filter_conditions.append(f"MONTH(next_maintenance_date) = {month_number}")
            if selected_part_number_output != "All":
                if selected_part_number_output == "With Part Number":
                    filter_conditions.append(f"part_number != 'N/A'")
                else:
                    filter_conditions.append(f"part_number = 'N/A'")
            if selected_job_activity_output != "All":
                filter_conditions.append(f"deskripsi LIKE '%{selected_job_activity_output}%'")

            self.electric_last_filter_conditions = filter_conditions  # simpan kondisi filter terakhir
            self.electric_update_output_with_filter_conditions()

        except Exception as e:
            print("Error in electric_apply_filters:", e)
            import traceback
            print(traceback.format_exc())


    def apply_filters_next_maintenance(self):
        selected_labor = self.search_by_labor_combo.currentText()
        selected_name = self.search_by_name_combo.currentText()
        selected_part = self.search_by_part_combo.currentText()
        selected_option = self.month_filter_combo.currentText()

        for row in range(self.next_maintenance_table.rowCount()):
            machine_labor_item = self.next_maintenance_table.item(row, 0)
            machine_name_item = self.next_maintenance_table.item(row, 1)
            part_name_item = self.next_maintenance_table.item(row, 2)
            date_item = self.next_maintenance_table.item(row, 11)

            should_display = True
            if selected_labor != "All" and machine_labor_item.text() != selected_labor:
                should_display = False
            elif selected_name != "All" and machine_name_item.text() != selected_name:
                should_display = False
            elif selected_part != "All" and part_name_item.text() != selected_part:
                should_display = False
            elif selected_option != "All" and selected_option != "Specific Date":
                try:
                    date = datetime.datetime.strptime(date_item.text(), "%Y-%m-%d")
                    if date.strftime("%B") != selected_option:
                        should_display = False
                except ValueError:
                    should_display = False

            self.next_maintenance_table.setRowHidden(row, not should_display)

    def electric_apply_filters_next_maintenance(self):
        # Ambil nilai dari setiap QComboBox
        selected_labor = self.electric_search_by_labor_combo.currentText()
        selected_name = self.electric_search_by_name_combo.currentText()
        selected_part = self.electric_search_by_part_combo.currentText()
        selected_month = self.electric_month_filter_combo.currentText()

        for row in range(self.electric_next_maintenance_table.rowCount()):
            machine_labor_item = self.electric_next_maintenance_table.item(row, 0)
            machine_name_item = self.electric_next_maintenance_table.item(row, 1)
            part_name_item = self.electric_next_maintenance_table.item(row, 2)
            date_item = self.electric_next_maintenance_table.item(row, 8)  # Anda mungkin perlu menyesuaikan indeks kolom

            should_display = True
            if selected_labor != "All" and machine_labor_item.text() != selected_labor:
                should_display = False
            elif selected_name != "All" and machine_name_item.text() != selected_name:
                should_display = False
            elif selected_part != "All" and part_name_item.text() != selected_part:
                should_display = False
            elif selected_month != "All":
                try:
                    date = datetime.datetime.strptime(date_item.text(), "%Y-%m-%d")
                    if date.strftime("%B") != selected_month:
                        should_display = False
                except ValueError:
                    should_display = False

            self.electric_next_maintenance_table.setRowHidden(row, not should_display)

    def apply_filters_history(self):
        try:
            selected_labor_history = self.search_by_labor_combo_history.currentText()
            selected_name_history = self.search_by_name_combo_history.currentText()
            selected_part_history = self.search_by_part_combo_history.currentText()
            selected_month_history = self.search_by_month_combo_history.currentText()
            selected_job_activity_history = self.search_by_job_activity_combo_history.currentText()
            selected_part_number_history = self.search_by_part_number_combo_history.currentText()

            filter_conditions_history = []
            if selected_labor_history != "All":
                filter_conditions_history.append(f"labor = '{selected_labor_history}'")
            if selected_name_history != "All":
                filter_conditions_history.append(f"name = '{selected_name_history}'")
            if selected_part_history != "All":
                filter_conditions_history.append(f"bagian_mesin = '{selected_part_history}'")
            if selected_month_history != "All":
                month_number_history = datetime.datetime.strptime(selected_month_history, '%B').month
                filter_conditions_history.append(f"MONTH(next_maintenance_date) = {month_number_history}")
            if selected_job_activity_history != "All":
                filter_conditions_history.append(f"deskripsi LIKE '%{selected_job_activity_history}%'")
            if selected_part_number_history != "All":
                if selected_part_number_history == "With Part Number":
                    filter_conditions_history.append(f"part_number != 'N/A'")
                else:
                    filter_conditions_history.append(f"part_number = 'N/A'")

            self.last_filter_conditions_history = filter_conditions_history  # simpan kondisi filter terakhir
            self.update_history_with_filter_conditions()

        except Exception as e:
            print("Error in apply_filters_history:", e)
            import traceback
            print(traceback.format_exc()) 

    def electric_apply_filters_history(self):
        try:
            selected_labor_history = self.electric_search_by_labor_combo_history.currentText()
            selected_name_history = self.electric_search_by_name_combo_history.currentText()
            selected_part_history = self.electric_search_by_part_combo_history.currentText()
            selected_month_history = self.electric_search_by_month_combo_history.currentText()
            selected_job_activity_history = self.electric_search_by_job_activity_combo_history.currentText()
            selected_part_number_history = self.electric_search_by_part_number_combo_history.currentText()

            filter_conditions_history = []
            if selected_labor_history != "All":
                filter_conditions_history.append(f"labor = '{selected_labor_history}'")
            if selected_name_history != "All":
                filter_conditions_history.append(f"name = '{selected_name_history}'")
            if selected_part_history != "All":
                filter_conditions_history.append(f"bagian_mesin = '{selected_part_history}'")
            if selected_month_history != "All":
                month_number_history = datetime.datetime.strptime(selected_month_history, '%B').month
                filter_conditions_history.append(f"MONTH(next_maintenance_date) = {month_number_history}")
            if selected_job_activity_history != "All":
                filter_conditions_history.append(f"deskripsi LIKE '%{selected_job_activity_history}%'")
            if selected_part_number_history != "All":
                if selected_part_number_history == "With Part Number":
                    filter_conditions_history.append(f"part_number != 'N/A'")
                else:
                    filter_conditions_history.append(f"part_number = 'N/A'")

            self.electric_last_filter_conditions_history = filter_conditions_history  # simpan kondisi filter terakhir
            self.electric_update_history_with_filter_conditions()

        except Exception as e:
            print("Error in electric_apply_filters_history:", e)
            import traceback
            print(traceback.format_exc())

    def sort_next_maintenance_table(self):
        self.next_maintenance_table.sortItems(5)  # Urutkan berdasarkan kolom "Next Maintenance Date"

    def sort_next_maintenance_electric_table(self):
        self.electric_next_maintenance_table.sortItems(5)  # Urutkan berdasarkan kolom "Next Maintenance Date"


    def delete_inner_frame(self, frame):
        try:
            # Temukan index dari frame yang ingin dihapus dalam layout
            index_to_remove = -1
            for i in range(self.container_layout.count()):
                if self.container_layout.itemAt(i).widget() == frame:
                    index_to_remove = i
                    break

            print("Index to remove:", index_to_remove)  # Menambahkan print statement

            if index_to_remove == -1:  # Jika frame tidak ditemukan
                return

            # Hapus input fields yang berhubungan dengan frame yang dihapus
            del self.details_inputs[index_to_remove]
            del self.standard_inputs[index_to_remove]
            del self.spare_part_inputs[index_to_remove]
            del self.part_number_inputs[index_to_remove]
            if not sip.isdeleted(self.maintenance_date_inputs[index_to_remove]):
                del self.maintenance_date_inputs[index_to_remove]
            else:
                print(f"Maintenance Date Input {index_to_remove} is already deleted")

            # Anda mungkin juga memiliki list lain yang perlu Anda hapus itemnya di sini

            # Hapus frame dari layout
            widget_to_remove = self.container_layout.takeAt(index_to_remove).widget()
            if widget_to_remove:
                widget_to_remove.deleteLater()

        except Exception as e:
            print("Error in delete_inner_frame:", e)
            import traceback
            print(traceback.format_exc())  # Ini akan mencetak stack trace untuk memberikan konteks error

    def electric_delete_inner_frame(self, frame):
        try:
            # Temukan index dari frame yang ingin dihapus dalam layout
            index_to_remove = -1
            for i in range(self.electric_container_layout.count()):
                if self.electric_container_layout.itemAt(i).widget() == frame:
                    index_to_remove = i
                    break

            print("Index to remove:", index_to_remove)  # Menambahkan print statement

            if index_to_remove == -1:  # Jika frame tidak ditemukan
                return

            # Hapus input fields yang berhubungan dengan frame yang dihapus
            del self.electric_details_inputs[index_to_remove]
            del self.electric_standard_inputs[index_to_remove]
            del self.electric_spare_part_inputs[index_to_remove]
            del self.electric_part_number_inputs[index_to_remove]
            if not sip.isdeleted(self.electric_maintenance_date_inputs[index_to_remove]):
                del self.electric_maintenance_date_inputs[index_to_remove]
            else:
                print(f"Electric Maintenance Date Input {index_to_remove} is already deleted")

            # Anda mungkin juga memiliki list lain yang perlu Anda hapus itemnya di sini

            # Hapus frame dari layout
            widget_to_remove = self.electric_container_layout.takeAt(index_to_remove).widget()
            if widget_to_remove:
                widget_to_remove.deleteLater()

        except Exception as e:
            print("Error in electric_delete_inner_frame:", e)
            import traceback
            print(traceback.format_exc())  # Ini akan mencetak stack trace untuk memberikan konteks error



    def add_entry(self):
        # Menampilkan kotak dialog konfirmasi
        reply = QMessageBox.question(self, 'Konfirmasi Entri',
                                     "Apakah Anda yakin dengan entri ini?", QMessageBox.Yes | 
                                     QMessageBox.No, QMessageBox.No)

        if reply == QMessageBox.Yes:
            if not self.validate_inputs():
                return

            labor = self.labor_combo.currentText()
            name = self.name_input.text()
            bagian_mesin = self.bagian_mesin_input.text()
            frequency_pemeriksaan = self.frequency_pemeriksaan_combo.currentText()

            try:
                iterasi_tahun = int(self.iterasi_combo.currentText().split()[0])  # Mengambil nilai iterasi sebagai integer
            except ValueError:
                print("Error: Unable to parse iterasi value")
                return

            if name and bagian_mesin:
                try:
                    initial_maintenance_date = None

                    for i in range(len(self.details_inputs)):
                        deskripsi = self.details_inputs[i].text()
                        standard = self.standard_inputs[i].text() if i < len(self.standard_inputs) else ""
                        spare_part = self.spare_part_inputs[i].text() if i < len(self.spare_part_inputs) else ""
                        part_number = self.part_number_inputs[i].text() if i < len(self.part_number_inputs) else ""

                        if i < len(self.maintenance_date_inputs) and not sip.isdeleted(self.maintenance_date_inputs[i]):
                            maintenance_date = datetime.datetime.strptime(self.maintenance_date_inputs[i].date().toString("yyyy-MM-dd"), "%Y-%m-%d")
                            print(f"Maintenance date from input {i}: {maintenance_date}")
                            if i == 0:
                                initial_maintenance_date = maintenance_date  
                        else:
                            if initial_maintenance_date:
                                maintenance_date = initial_maintenance_date 
                                print(f"Using initial maintenance date: {maintenance_date}")
                            else:
                                print("Error: No initial maintenance date found.")
                                return

                        if deskripsi:
                            frequency_pemeriksaan_days = self.frequency_pemeriksaan_to_days(frequency_pemeriksaan)
                            total_days = iterasi_tahun * 365  # Total hari dalam iterasi tahun
                            total_iterations = total_days // frequency_pemeriksaan_days  # Menghitung total iterasi

                            for j in range(total_iterations):
                                next_maintenance_date = maintenance_date + datetime.timedelta(days=frequency_pemeriksaan_days * (j+1))
                                next_maintenance_date_str = next_maintenance_date.strftime("%Y-%m-%d")

                                if not part_number:
                                    part_number = "N/A"

                                query = """
                                INSERT INTO machinePM (labor, name, bagian_mesin, frequency_pemeriksaan, deskripsi, spare_part, part_number, standard, date, next_maintenance_date, status, iterasi_tahun)
                                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                                """
                                values = (labor, name, bagian_mesin, frequency_pemeriksaan, deskripsi, spare_part, part_number, standard, maintenance_date.strftime("%Y-%m-%d"), next_maintenance_date_str, "Start", iterasi_tahun)
                                self.db_manager.execute_query(query, values)
                                row_position = self.table.rowCount()
                                self.table.insertRow(row_position)
                                self.table.setItem(row_position, 0, QTableWidgetItem(labor))
                                self.table.setItem(row_position, 1, QTableWidgetItem(name))
                                self.table.setItem(row_position, 8, QTableWidgetItem(maintenance_date.strftime("%Y-%m-%d")))
                                self.table.setItem(row_position, 9, QTableWidgetItem(next_maintenance_date_str))
                                self.table.setItem(row_position, 10, QTableWidgetItem("Start"))

                    self.populate_combo_output(self.search_by_labor_combo_output, 'labor')
                    self.populate_combo_output(self.search_by_name_combo_output, 'machine')
                    self.populate_combo_output(self.search_by_part_combo_output, 'part')

                    self.populate_combo_next_maintenance(self.search_by_labor_combo, 'labor')
                    self.populate_combo_next_maintenance(self.search_by_name_combo, 'machine')
                    self.populate_combo_next_maintenance(self.search_by_part_combo, 'part')
                    
                    self.populate_combo_history(self.search_by_labor_combo_history, 'labor')
                    self.populate_combo_history(self.search_by_name_combo_history, 'machine')
                    self.populate_combo_history(self.search_by_part_combo_history, 'part')
                    self.sort_next_maintenance_table()
                    self.reset_input_fields()
                    self.remove_additional_inner_frames()

                except ValueError:
                    print("Error: Unable to add entry due to ValueError")
                    return
                except Exception as e:
                    print(f"Error: {e}")
                    return
        else:
            # User clicked 'No', so do nothing
            pass


    def electric_add_entry(self):
        # Menampilkan kotak dialog konfirmasi
        reply = QMessageBox.question(self, 'Konfirmasi Entri',
                                    "Apakah Anda yakin dengan entri ini?", QMessageBox.Yes |
                                    QMessageBox.No, QMessageBox.No)

        if reply == QMessageBox.Yes:
            if not self.validate_electric_inputs():  # Asumsi Anda memiliki metode ini untuk memvalidasi input
                return

            labor = self.electric_labor_combo.currentText()
            name = self.electric_name_input.text()
            bagian_mesin = self.electric_bagian_mesin_input.text()
            frequency_pemeriksaan = self.electric_frequency_pemeriksaan_combo.currentText()

            try:
                iterasi_tahun = int(self.electric_iterasi_combo.currentText().split()[0])  # Mengambil nilai iterasi sebagai integer
            except ValueError:
                print("Error: Unable to parse iterasi value")
                return

            if name and bagian_mesin:
                try:
                    initial_maintenance_date = None

                    for i in range(len(self.electric_details_inputs)):
                        deskripsi = self.electric_details_inputs[i].text()
                        standard = self.electric_standard_inputs[i].text() if i < len(self.electric_standard_inputs) else ""
                        spare_part = self.electric_spare_part_inputs[i].text() if i < len(self.electric_spare_part_inputs) else ""
                        part_number = self.electric_part_number_inputs[i].text() if i < len(self.electric_part_number_inputs) else ""

                        if i < len(self.electric_maintenance_date_inputs) and not sip.isdeleted(self.electric_maintenance_date_inputs[i]):
                            maintenance_date = datetime.datetime.strptime(self.electric_maintenance_date_inputs[i].date().toString("yyyy-MM-dd"), "%Y-%m-%d")
                            print(f"Maintenance date from input {i}: {maintenance_date}")
                            if i == 0:
                                initial_maintenance_date = maintenance_date  
                        else:
                            if initial_maintenance_date:
                                maintenance_date = initial_maintenance_date 
                                print(f"Using initial maintenance date: {maintenance_date}")
                            else:
                                print("Error: No initial maintenance date found.")
                                return

                        if deskripsi:
                            frequency_pemeriksaan_days = self.electric_frequency_pemeriksaan_to_days(frequency_pemeriksaan)  # Asumsi Anda memiliki metode ini
                            total_days = iterasi_tahun * 365  # Total hari dalam iterasi tahun
                            total_iterations = total_days // frequency_pemeriksaan_days  # Menghitung total iterasi

                            for j in range(total_iterations):
                                next_maintenance_date = maintenance_date + datetime.timedelta(days=frequency_pemeriksaan_days * (j+1))
                                next_maintenance_date_str = next_maintenance_date.strftime("%Y-%m-%d")

                                if not part_number:
                                    part_number = "N/A"

                                query = """
                                INSERT INTO electricPM (labor, name, bagian_mesin, frequency_pemeriksaan, deskripsi, spare_part, part_number, standard, date, next_maintenance_date, status, iterasi_tahun)
                                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                                """
                                values = (labor, name, bagian_mesin, frequency_pemeriksaan, deskripsi, spare_part, part_number, standard, maintenance_date.strftime("%Y-%m-%d"), next_maintenance_date_str, "Start", iterasi_tahun)
                                self.db_manager.execute_query(query, values)
                                row_position = self.electric_table.rowCount()  # Asumsi Anda memiliki tabel ini
                                self.electric_table.insertRow(row_position)
                                self.electric_table.setItem(row_position, 0, QTableWidgetItem(labor))
                                self.electric_table.setItem(row_position, 1, QTableWidgetItem(name))
                                self.electric_table.setItem(row_position, 8, QTableWidgetItem(maintenance_date.strftime("%Y-%m-%d")))
                                self.electric_table.setItem(row_position, 9, QTableWidgetItem(next_maintenance_date_str))
                                self.electric_table.setItem(row_position, 10, QTableWidgetItem("Start"))

                            self.electric_populate_combo_output(self.electric_search_by_labor_combo_output, 'labor')
                            self.electric_populate_combo_output(self.electric_search_by_name_combo_output, 'labor')
                            self.electric_populate_combo_output(self.electric_search_by_part_combo_output, 'labor')

                            self.electric_populate_combo_next_maintenance(self.electric_search_by_labor_combo, 'labor')
                            self.electric_populate_combo_next_maintenance(self.electric_search_by_name_combo, 'machine')
                            self.electric_populate_combo_next_maintenance(self.electric_search_by_part_combo, 'part')

                    self.electric_remove_additional_inner_frames()
                    self.electric_reset_input_fields()
                    self.sort_next_maintenance_electric_table()

                except ValueError:
                    print("Error: Unable to add entry due to ValueError")
                    return
                except Exception as e:
                    print(f"Error: {e}")
                    return
        else:
            # User clicked 'No', so do nothing
            pass


    # Metode untuk menghapus inner frames tambahan
    def remove_additional_inner_frames(self):
        # Ambil jumlah total inner frames
        total_inner_frames = self.container_layout.count()

        # Mulai dari yang terakhir, hapus hingga satu yang tersisa
        for i in range(total_inner_frames - 1, 0, -1):
            widget_to_remove = self.container_layout.itemAt(i).widget()
            if widget_to_remove:
                widget_to_remove.deleteLater()
                self.container_layout.removeItem(self.container_layout.itemAt(i))

        # Reset input field yang tersisa
        if self.details_inputs:
            self.details_inputs[0].clear()
        if self.standard_inputs:
            self.standard_inputs[0].clear()
        if self.spare_part_inputs:
            self.spare_part_inputs[0].clear()
        if self.part_number_inputs:
            self.part_number_inputs[0].clear()

        # Menghapus dari list juga
        while len(self.details_inputs) > 1:
            self.details_inputs.pop().deleteLater()
            self.standard_inputs.pop().deleteLater()
            self.spare_part_inputs.pop().deleteLater()
            self.part_number_inputs.pop().deleteLater()

        # Reset input field pertama
        self.details_inputs[0].clear()
        self.standard_inputs[0].clear()
        self.spare_part_inputs[0].clear()
        self.part_number_inputs[0].clear()


    def electric_remove_additional_inner_frames(self):
        # Ambil jumlah total inner frames
        total_inner_frames = self.electric_container_layout.count()

        # Mulai dari yang terakhir, hapus hingga satu yang tersisa
        for i in range(total_inner_frames - 1, 0, -1):
            widget_to_remove = self.electric_container_layout.itemAt(i).widget()
            if widget_to_remove:
                widget_to_remove.deleteLater()
                self.electric_container_layout.removeItem(self.electric_container_layout.itemAt(i))

        # Reset input field yang tersisa
        if self.electric_details_inputs:
            self.electric_details_inputs[0].clear()
        if self.electric_standard_inputs:
            self.electric_standard_inputs[0].clear()
        if self.electric_spare_part_inputs:
            self.electric_spare_part_inputs[0].clear()
        if self.electric_part_number_inputs:
            self.electric_part_number_inputs[0].clear()

        # Menghapus dari list juga
        while len(self.electric_details_inputs) > 1:
            self.electric_details_inputs.pop().deleteLater()
            self.electric_standard_inputs.pop().deleteLater()
            self.electric_spare_part_inputs.pop().deleteLater()
            self.electric_part_number_inputs.pop().deleteLater()

        # Reset input field pertama
        self.electric_details_inputs[0].clear()
        self.electric_standard_inputs[0].clear()
        self.electric_spare_part_inputs[0].clear()
        self.electric_part_number_inputs[0].clear()

        
    def reset_input_fields(self):
        # Mengatur ulang input fields ke nilai default
        self.name_input.clear()
        self.bagian_mesin_input.clear()
        
        # Mengatur ulang self.frequency_pemeriksaan_combo
        self.frequency_pemeriksaan_combo.setCurrentIndex(0)  # Pilih opsi "Pilih Frequency"
        
        # Mengatur ulang self.labor_combo
        self.labor_combo.setCurrentIndex(0)  # Pilih opsi "Pilih Area / Labor"

        # Mengatur ulang self.iterasi_combo
        self.iterasi_combo.setCurrentIndex(0)  # Pilih opsi "Pilih Iterasi"

    def electric_reset_input_fields(self):
        # Mengatur ulang input fields ke nilai default
        self.electric_name_input.clear()
        self.electric_bagian_mesin_input.clear()

        # Mengatur ulang self.electric_frequency_pemeriksaan_combo
        self.electric_frequency_pemeriksaan_combo.setCurrentIndex(0)  # Pilih opsi "Pilih Frequency"

        # Mengatur ulang self.electric_labor_combo
        self.electric_labor_combo.setCurrentIndex(0)  # Pilih opsi "Pilih Area / Labor"

        # Mengatur ulang self.electric_iterasi_combo
        self.electric_iterasi_combo.setCurrentIndex(0)  # Pilih opsi "Pilih Iterasi"




    def reset_input_fields_electric(self):
        # Reset the input fields for the "Electric" tab
        self.kode_input_electric.clear()
        self.name_input_electric.clear()
        self.frequency_pemeriksaan_combo_electric.setCurrentIndex(0) 

    def update_maintenance_entries(self):
                    pass
    
    def electric_update_maintenance_entries(self):
                pass

    def update_machine_and_part_combos(self):
        selected_labor = self.search_by_labor_combo_output.currentText()
        if selected_labor and selected_labor != "All":
            # Query to get all machine names associated with the selected labor
            query_machines = f"SELECT DISTINCT name FROM machinePM WHERE labor = '{selected_labor}'"
            machines = self.db_manager.fetch_data(query_machines)

            # Update the name combo box with the query results
            self.search_by_name_combo_output.clear()
            self.search_by_name_combo_output.addItem("All")
            self.search_by_name_combo_output.addItems([machine[0] for machine in machines])
        else:
            # If "All" is selected, reset the name combo box
            self.search_by_name_combo_output.clear()
            self.search_by_name_combo_output.addItem("All")

    def update_part_combo(self):
        selected_labor = self.search_by_labor_combo_output.currentText()
        selected_name = self.search_by_name_combo_output.currentText()

        self.search_by_part_combo_output.clear()
        self.search_by_part_combo_output.addItem("All")

        if selected_name != "All":
            query_parts = f"SELECT DISTINCT bagian_mesin FROM machinePM WHERE name = '{selected_name}'"
            parts = self.db_manager.fetch_data(query_parts)
            self.search_by_part_combo_output.addItems([part[0] for part in parts])

        elif selected_labor != "All":
            query_parts = f"SELECT DISTINCT bagian_mesin FROM machinePM WHERE labor = '{selected_labor}'"
            parts = self.db_manager.fetch_data(query_parts)
            self.search_by_part_combo_output.addItems([part[0] for part in parts])

    def electric_update_machine_and_part_combos(self):
        selected_labor = self.electric_search_by_labor_combo_output.currentText()
        if selected_labor and selected_labor != "All":
            # Query to get all machine names associated with the selected labor
            query_machines = f"SELECT DISTINCT name FROM electricPM WHERE labor = '{selected_labor}'"
            machines = self.db_manager.fetch_data(query_machines)

            # Update the name combo box with the query results
            self.electric_search_by_name_combo_output.clear()
            self.electric_search_by_name_combo_output.addItem("All")
            self.electric_search_by_name_combo_output.addItems([machine[0] for machine in machines])
        else:
            # If "All" is selected, reset the name combo box
            self.electric_search_by_name_combo_output.clear()
            self.electric_search_by_name_combo_output.addItem("All")

    def electric_update_part_combo(self):
        selected_labor = self.electric_search_by_labor_combo_output.currentText()
        selected_name = self.electric_search_by_name_combo_output.currentText()

        self.electric_search_by_part_combo_output.clear()
        self.electric_search_by_part_combo_output.addItem("All")

        if selected_name != "All":
            query_parts = f"SELECT DISTINCT bagian_mesin FROM electricPM WHERE name = '{selected_name}'"
            parts = self.db_manager.fetch_data(query_parts)
            self.electric_search_by_part_combo_output.addItems([part[0] for part in parts])

        elif selected_labor != "All":
            query_parts = f"SELECT DISTINCT bagian_mesin FROM electricPM WHERE labor = '{selected_labor}'"
            parts = self.db_manager.fetch_data(query_parts)
            self.electric_search_by_part_combo_output.addItems([part[0] for part in parts])

    def update_machine_combo_next_maintenance(self):
        selected_labor = self.search_by_labor_combo.currentText()
        self.search_by_name_combo.clear()
        self.search_by_name_combo.addItem("All")

        if selected_labor and selected_labor != "All":
            query_machines = f"SELECT DISTINCT name FROM machinePM WHERE labor = '{selected_labor}'"
            machines = self.db_manager.fetch_data(query_machines)
            self.search_by_name_combo.addItems([machine[0] for machine in machines])

    def update_part_combo_next_maintenance(self):
        selected_name = self.search_by_name_combo.currentText()
        self.search_by_part_combo.clear()
        self.search_by_part_combo.addItem("All")

        if selected_name and selected_name != "All":
            query_parts = f"SELECT DISTINCT bagian_mesin FROM machinePM WHERE name = '{selected_name}'"
            parts = self.db_manager.fetch_data(query_parts)
            self.search_by_part_combo.addItems([part[0] for part in parts])


    def update_machine_and_part_combos_history(self):
        selected_labor = self.search_by_labor_combo_history.currentText()
        if selected_labor and selected_labor != "All":
            # Query to get all machine names associated with the selected labor
            query_machines = f"SELECT DISTINCT name FROM machinePM WHERE labor = '{selected_labor}'"
            machines = self.db_manager.fetch_data(query_machines)

            # Update the name combo box with the query results
            self.search_by_name_combo_history.clear()
            self.search_by_name_combo_history.addItem("All")
            self.search_by_name_combo_history.addItems([machine[0] for machine in machines])
        else:
            # If "All" is selected, reset the name combo box
            self.search_by_name_combo_history.clear()
            self.search_by_name_combo_history.addItem("All")

    def update_part_combo_history(self):
        selected_labor = self.search_by_labor_combo_history.currentText()
        selected_name = self.search_by_name_combo_history.currentText()

        self.search_by_part_combo_history.clear()
        self.search_by_part_combo_history.addItem("All")

        if selected_name != "All":
            query_parts = f"SELECT DISTINCT bagian_mesin FROM machinePM WHERE name = '{selected_name}'"
            parts = self.db_manager.fetch_data(query_parts)
            self.search_by_part_combo_history.addItems([part[0] for part in parts])

        elif selected_labor != "All":
            query_parts = f"SELECT DISTINCT bagian_mesin FROM machinePM WHERE labor = '{selected_labor}'"
            parts = self.db_manager.fetch_data(query_parts)
            self.search_by_part_combo_history.addItems([part[0] for part in parts])

    def electric_update_machine_and_part_combos_history(self):
        selected_labor = self.electric_search_by_labor_combo_history.currentText()
        if selected_labor and selected_labor != "All":
            # Query to get all machine names associated with the selected labor
            query_machines = f"SELECT DISTINCT name FROM electricPM WHERE labor = '{selected_labor}'"
            machines = self.db_manager.fetch_data(query_machines)

            # Update the name combo box with the query results
            self.electric_search_by_name_combo_history.clear()
            self.electric_search_by_name_combo_history.addItem("All")
            self.electric_search_by_name_combo_history.addItems([machine[0] for machine in machines])
        else:
            # If "All" is selected, reset the name combo box
            self.electric_search_by_name_combo_history.clear()
            self.electric_search_by_name_combo_history.addItem("All")

    def electric_update_part_combo_history(self):
        selected_labor = self.electric_search_by_labor_combo_history.currentText()
        selected_name = self.electric_search_by_name_combo_history.currentText()

        self.electric_search_by_part_combo_history.clear()
        self.electric_search_by_part_combo_history.addItem("All")

        if selected_name != "All":
            query_parts = f"SELECT DISTINCT bagian_mesin FROM electricPM WHERE name = '{selected_name}'"
            parts = self.db_manager.fetch_data(query_parts)
            self.electric_search_by_part_combo_history.addItems([part[0] for part in parts])

        elif selected_labor != "All":
            query_parts = f"SELECT DISTINCT bagian_mesin FROM electricPM WHERE labor = '{selected_labor}'"
            parts = self.db_manager.fetch_data(query_parts)
            self.electric_search_by_part_combo_history.addItems([part[0] for part in parts])
    
    def frequency_pemeriksaan_to_days(self, frequency_pemeriksaan):
        # Fungsi ini mengonversi pilihan Frequency menjadi jumlah hari
        if frequency_pemeriksaan == "1W":
            return 7
        elif frequency_pemeriksaan == "2W":
            return 14
        elif frequency_pemeriksaan == "1M":
            return 30
        elif frequency_pemeriksaan == "3M":
            return 90
        elif frequency_pemeriksaan == "6M":
            return 180
        elif frequency_pemeriksaan == "1Y":
            return 365
        elif frequency_pemeriksaan == "2Y":
            return 365 * 2
        elif frequency_pemeriksaan == "3Y":
            return 365 * 3
        elif frequency_pemeriksaan == "4Y":
            return 365 * 4
        elif frequency_pemeriksaan == "5Y":
            return 365 * 5
        else:
            return 30  # Default jika tidak ada yang cocok
        
    def electric_frequency_pemeriksaan_to_days(self, electric_frequency_pemeriksaan):
        # This function converts the Frequency choice into number of days
        if electric_frequency_pemeriksaan == "1W":
            return 7
        elif electric_frequency_pemeriksaan == "2W":
            return 14
        elif electric_frequency_pemeriksaan == "1M":
            return 30
        elif electric_frequency_pemeriksaan == "3M":
            return 90
        elif electric_frequency_pemeriksaan == "6M":
            return 180
        elif electric_frequency_pemeriksaan == "1Y":
            return 365
        elif electric_frequency_pemeriksaan == "2Y":
            return 365 * 2
        elif electric_frequency_pemeriksaan == "3Y":
            return 365 * 3
        elif electric_frequency_pemeriksaan == "4Y":
            return 365 * 4
        elif electric_frequency_pemeriksaan == "5Y":
            return 365 * 5
        else:
            return 30  # Default if none match

           
    def validate_inputs(self):
        # Validasi untuk Labor
        selected_labor = self.labor_combo.currentText()
        if selected_labor == "Pilih Area / Labor":
            QMessageBox.warning(self, "Validation Error", "Please select a valid Area / Labor!")
            return False
        # Validasi untuk Name
        name = self.name_input.text().strip()
        if not name:
            QMessageBox.warning(self, "Validation Error", "Name is required!")
            return False

        # Validasi untuk Bagian Mesin
        bagian_mesin = self.bagian_mesin_input.text().strip()
        if not bagian_mesin:
            QMessageBox.warning(self, "Validation Error", "Bagian Mesin is required!")
            return False

        # Validasi untuk Frequency Pemeriksaan
        selected_frequency = self.frequency_pemeriksaan_combo.currentText()
        if selected_frequency == "Pilih Frequency":
            QMessageBox.warning(self, "Validation Error", "Please select a valid Frequency Pemeriksaan!")
            return False

        # Validasi untuk Iterasi
        selected_iterasi = self.iterasi_combo.currentText()
        if selected_iterasi == "Pilih Iterasi":
            QMessageBox.warning(self, "Validation Error", "Please select a valid Iterasi!")
            return False

        # Loop through each spare part input to validate
        for spare_part_input in self.spare_part_inputs:
            if isinstance(spare_part_input, QLineEdit):
                spare_part = spare_part_input.text().strip()
                if not spare_part:
                    QMessageBox.warning(self, "Validation Error", "Spare Part is required for every entry!")
                    return False

        for detail_input in self.details_inputs:
            deskripsi = detail_input.text().strip() if isinstance(detail_input, QLineEdit) else ""
            if not deskripsi:
                QMessageBox.warning(self, "Validation Error", "Deskripsi is required!")
                return False

        for standard in self.standard_inputs:
            std_value = standard.text().strip() if isinstance(standard, QLineEdit) else ""
            if not std_value:
                QMessageBox.warning(self, "Validation Error", "Standard is required!")
                return False

        return True
    
    def validate_electric_inputs(self):
        # Validasi untuk Labor
        selected_labor = self.electric_labor_combo.currentText()
        if selected_labor == "Pilih Area / Labor":
            QMessageBox.warning(self, "Validation Error", "Please select a valid Area / Labor!")
            return False
        # Validasi untuk Name
        name = self.electric_name_input.text().strip()
        if not name:
            QMessageBox.warning(self, "Validation Error", "Name is required!")
            return False

        # Validasi untuk Bagian Mesin
        bagian_mesin = self.electric_bagian_mesin_input.text().strip()
        if not bagian_mesin:
            QMessageBox.warning(self, "Validation Error", "Bagian Mesin is required!")
            return False

        # Validasi untuk Frequency Pemeriksaan
        selected_frequency = self.electric_frequency_pemeriksaan_combo.currentText()
        if selected_frequency == "Pilih Frequency":
            QMessageBox.warning(self, "Validation Error", "Please select a valid Frequency Pemeriksaan!")
            return False

        # Validasi untuk Iterasi
        selected_iterasi = self.electric_iterasi_combo.currentText()
        if selected_iterasi == "Pilih Iterasi":
            QMessageBox.warning(self, "Validation Error", "Please select a valid Iterasi!")
            return False

        # Loop through each spare part input to validate
        for spare_part_input in self.electric_spare_part_inputs:
            if isinstance(spare_part_input, QLineEdit):
                spare_part = spare_part_input.text().strip()
                if not spare_part:
                    QMessageBox.warning(self, "Validation Error", "Spare Part is required for every entry!")
                    return False

        for detail_input in self.electric_details_inputs:
            deskripsi = detail_input.text().strip() if isinstance(detail_input, QLineEdit) else ""
            if not deskripsi:
                QMessageBox.warning(self, "Validation Error", "Deskripsi is required!")
                return False

        for standard in self.electric_standard_inputs:
            std_value = standard.text().strip() if isinstance(standard, QLineEdit) else ""
            if not std_value:
                QMessageBox.warning(self, "Validation Error", "Standard is required!")
                return False

        return True
    
    def print_next_maintenance(self):
        data = self.get_next_maintenance_data()
        if not data.empty:
            html = self.data_to_html(data)
            self.show_html_preview(html)

    def print_html(self, html):
    # Set a new cache path
        profile = QWebEngineProfile.defaultProfile()
        profile.setCachePath("some/other/path")
        settings = QWebEngineSettings.globalSettings()
        settings.setAttribute(QWebEngineSettings.LocalStorageEnabled, False)
        self.printer = QPrinter(QPrinter.HighResolution)
        self.view = QWebEngineView()
        self.page = self.view.page()
        self.page.setHtml(html)
        # Connect the loadFinished signal to a slot that handles printing
        self.page.loadFinished.connect(self.handle_load_finished)

    def handle_load_finished(self, success):
        # Check if the page was loaded successfully
        if success:
            dialog = QPrintDialog(self.printer, self)
            if dialog.exec_() == QPrintDialog.Accepted:
                # Now print the page to the printer
                self.page.print(self.printer, self.print_finished)
        else:
            print("Failed to load HTML content")

    def print_finished(self, success):
        if success:
            print("Printing completed successfully")
        else:
            print("Printing failed")


    def get_next_maintenance_data(self):
        # Mengumpulkan data dari QTableWidget
        # (Contoh ini menggunakan pandas, tapi Anda bisa melakukan ini secara manual juga)
        rows = self.next_maintenance_table.rowCount()
        # Kolom-kolom yang ingin diambil
        desired_columns = ["Labor", "Nama Mesin", "Bagian Mesin", "Freq", "Job Activity", "Spare Part", "PN", "Standard", "Checklist", "Comment"]
        data = []
        for row in range(rows):
            # Skip rows that have been filtered out and are not visible
            if self.next_maintenance_table.isRowHidden(row):
                continue

            row_data = {}
            for col, header in enumerate(desired_columns):
                # Menangani kolom checklist dan comment secara terpisah
                if header == "Checklist":
                    checkbox_widget = self.next_maintenance_table.cellWidget(row, 8)  # Mengasumsikan kolom "Checklist" adalah kolom ke-9
                    if checkbox_widget:
                        layout = checkbox_widget.layout()
                        checkbox = layout.itemAt(0).widget()
                        row_data[header] = "Checked" if checkbox.isChecked() else "Unchecked"
                    else:
                        row_data[header] = "Unchecked"  # Assume unchecked if the widget is not present
                elif header == "Comment":
                    item = self.next_maintenance_table.item(row, 9)  # Mengasumsikan kolom "Comment" adalah kolom ke-10
                    row_data[header] = item.text() if item else ""
                else:
                    item = self.next_maintenance_table.item(row, col)
                    if item:
                        row_data[header] = item.text()
            data.append(row_data)
        return pd.DataFrame(data)

    def data_to_html(self, data):
        # Menambahkan kolom placeholder 'Checklist' dan 'Comment' ke dataframe
        data['Checklist'] = ['<div style="text-align: center;"><input type="checkbox" style="transform: scale(1.5);"></div>' for _ in range(len(data))]
        data['Comment'] = ['<div contenteditable="true" style="min-height:15px;"></div>' for _ in range(len(data))]

        # Mengonversi data menjadi string HTML dengan menonaktifkan escaping untuk memungkinkan HTML dalam dataframe
        html_string = data.to_html(classes='table table-striped', index=False, escape=False)

        # Menguraikan string HTML dengan BeautifulSoup
        soup = BeautifulSoup(html_string, 'html.parser')

        # Mendapatkan jalur absolut dari file gambar
        script_dir = os.path.dirname(os.path.abspath(__file__))
        logo_path = os.path.join(script_dir, 'conwood.png')

        # Membaca file gambar dan mengonversinya ke string base64
        with open(logo_path, "rb") as image_file:
            encoded_string = base64.b64encode(image_file.read()).decode()

        # Membuat tag div baru untuk menampung logo dan teks
        header_div = soup.new_tag('div', style='display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;')
        logo_tag = soup.new_tag("img", src=f"data:image/png;base64,{encoded_string}", align="left", width="150")
        header_div.append(logo_tag)
        text_div = soup.new_tag('div', style='flex-grow: 1; text-align: center;')
        text_span = soup.new_tag('span', style='font-size: 17px; font-weight: bold;')
        text_span.string = "Checklist Pemeriksaan Mesin"
        text_div.append(text_span)
        header_div.append(text_div)
        soup.insert(0, header_div)

        signature_div = soup.new_tag('div', style='display: flex; justify-content: flex-end; margin-top: 50px; margin-right: 30px')
        
        # Membuat kolom untuk PIC
        pic_col = soup.new_tag('div', style='text-align: center; margin-right: 60px;')  # Adjust margin as needed
        pic_title = soup.new_tag('div', style='font-weight: bold;')
        pic_title.string = "PIC"
        pic_col.append(pic_title)
        pic_signature = soup.new_tag('div', style='height: 50px; width: 200px; border-bottom: 1px solid black;')
        pic_col.append(pic_signature)
        signature_div.append(pic_col)

        # Membuat kolom untuk Supervisor
        supervisor_col = soup.new_tag('div', style='text-align: center;')
        supervisor_title = soup.new_tag('div', style='font-weight: bold;')
        supervisor_title.string = "Supervisor"
        supervisor_col.append(supervisor_title)
        supervisor_signature = soup.new_tag('div', style='height: 50px; width: 200px; border-bottom: 1px solid black;')
        supervisor_col.append(supervisor_signature)
        signature_div.append(supervisor_col)

        # Menambahkan div tanda tangan ke soup
        soup.append(signature_div)

        # Menambahkan styling untuk border-collapse, ukuran font, dan padding
        style_tag = soup.new_tag("style")
        style_tag.string = """
        table, th, td {
            border: 1px solid black;
            border-collapse: collapse;
            font-size: 11px;
            padding-left: 5px;
            padding-right: 5px;
        }
        th {
            text-align: center;
            background-color: grey;
        }
        .table-striped tbody tr td:nth-child(9) { /* Checklist column, now correctly centered */
            text-align: center; 
            vertical-align: middle;
        }
        .table-striped tbody tr td:nth-child(10) { /* Comment column, should now be wider */
            width: 30%;
            min-width: 50px; /* or any other width */
        }
        """
        soup.insert(1, style_tag)

        # Mengubah styling tabel (misalnya, mengatur lebar tabel menjadi 100%)
        table_tag = soup.find('table')
        table_tag['style'] = 'width: 100%;'

        # Mengembalikan HTML yang dimodifikasi sebagai string
        return str(soup)

    def show_html_preview(self, html):
        # Display HTML preview
        html_preview = QWebEngineView()
        html_preview.setHtml(html)
        dialog = QDialog(self)
        dialog_layout = QVBoxLayout()
        dialog_layout.addWidget(html_preview)
        dialog.setLayout(dialog_layout)
        
        # Set dialog size to A4 dimensions in pixels for landscape orientation
        # You might need to adjust these dimensions based on your screen's DPI
        a4_height_px = 794  # Approx. A4 height in pixels for 96 DPI
        a4_width_px = 1123  # Approx. A4 width in pixels for 96 DPI
        dialog.resize(a4_width_px, a4_height_px)
        
        dialog.exec_()
        
def main():
    app = QApplication(sys.argv)
    window = MaintenanceApp()
    window.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
